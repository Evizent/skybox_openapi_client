# coding: utf-8

"""
    SkyBox API

    The SkyBox APIs allow our users to create, update, delete, and export information within the SkyBox platform. These APIs allow SkyBox to be extensible, giving you the flexibility to grow, develop, and integrate third-party tooling to help scale out your business. To begin using the SkyBox APIs, you will need to generate two unique tokens: an Application_Token and an API Token.  To request a unique Application_Token, click here (<a href='https://skybox.vividseats.com/application-sign-up'>https://skybox.vividseats.com/application-sign-up</a>) and refer to this <a href='https://skybox.zendesk.com/hc/en-us/articles/6769735238043-Getting-Started-with-Skybox-APIs'>Zendesk Article</a> for detailed instructions on getting started with SkyBox APIs.  To generate an API Token when logged in to SkyBox, click on the drop-down under 'Logged In As:', select 'External Accounts', and then select 'API Invitation +'. A modal will appear and you will be prompted to enter the email address to which you want the token sent as well as to provide a brief description of the account.  Once you have both your Application_Token and API Token, there are two ways in which you can make requests: through the UI and through a third party. See below for detailed steps for each process.  Requests through the UI:  To begin, enter your Account ID in the X-Account field. Once complete, select _Authorize_. Next, enter your API Token in the X-Api-Token field. If you do not currently have an API Token, please follow the steps above to request one. Once complete, select _Authorize_. Last, enter your Application_Token in the X-Application-Token field. If you do not have an Application_Token, a sample is provided or you can follow the link above to request one. Once complete, select _Authorize_.  Requests through a third party (i.e. Postman):  The same information is required as it is through the UI, but it will be passed in through headers. It should look something like this:  X-Account: Account ID goes here!  X-Api-Token: API Token goes here!  X-Application-Token: Application_Token goes here!  Once these three items are successfully passed in as headers, you will be able to make sample requests.  <h2><a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>API Rate Limits</a> </h2>  A rate limit consists of two variables: an interval and a limit. An interval is a period of time, measured in seconds. A limit is the number of calls that can be made to an endpoint in an interval.  For example, SkyBox’s ‘GET /reports/‘ endpoint has an interval of 1 second and a limit of 1 call per interval. This means that this endpoint has a rate limit of 1 call/second.  Each endpoint, and its respective rate limit, is displayed in this <a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>Support Article</a>. If the endpoint is not listed, its rate limit is the default, indicated by the ‘*’ at the bottom of the table. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from skybox_openapi_client.models.bulk_inventory_update_request import BulkInventoryUpdateRequest
from skybox_openapi_client.models.bulk_sold_swap_event_request import BulkSoldSwapEventRequest
from skybox_openapi_client.models.bulk_swap_event_request import BulkSwapEventRequest
from skybox_openapi_client.models.exchange_pos_id_history_response import ExchangePosIdHistoryResponse
from skybox_openapi_client.models.expected_value_update_bulk import ExpectedValueUpdateBulk
from skybox_openapi_client.models.hold import Hold
from skybox_openapi_client.models.inventory import Inventory
from skybox_openapi_client.models.inventory_barcode_response import InventoryBarcodeResponse
from skybox_openapi_client.models.inventory_face_value_update_bulk import InventoryFaceValueUpdateBulk
from skybox_openapi_client.models.inventory_price_history import InventoryPriceHistory
from skybox_openapi_client.models.inventory_price_update_bulk import InventoryPriceUpdateBulk
from skybox_openapi_client.models.inventory_summary import InventorySummary
from skybox_openapi_client.models.inventory_taxed_cost_update_bulk import InventoryTaxedCostUpdateBulk
from skybox_openapi_client.models.merge_inventory_request import MergeInventoryRequest
from skybox_openapi_client.models.purchased_inventory_summary import PurchasedInventorySummary
from skybox_openapi_client.models.purchased_inventory_summary_v2 import PurchasedInventorySummaryV2
from skybox_openapi_client.models.sold_inventory_summary import SoldInventorySummary
from skybox_openapi_client.models.sync_inventory_request import SyncInventoryRequest
from skybox_openapi_client.models.tag_request import TagRequest
from skybox_openapi_client.models.update_purchase_inventory_request import UpdatePurchaseInventoryRequest

from skybox_openapi_client.api_client import ApiClient, RequestSerialized
from skybox_openapi_client.api_response import ApiResponse
from skybox_openapi_client.rest import RESTResponseType


class InventoryApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def inventory_bulk_merge(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Inventory]:
        """inventory_bulk_merge

        Merge all eligible inventories

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_merge_with_http_info(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Inventory]]:
        """inventory_bulk_merge

        Merge all eligible inventories

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_merge_without_preload_content(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_merge

        Merge all eligible inventories

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_merge_serialize(
        self,
        merge_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merge_inventory_request is not None:
            _body_params = merge_inventory_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/bulk-merge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_remove_tags(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param request_body: Inventory Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_remove_tags_with_http_info(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param request_body: Inventory Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_remove_tags_without_preload_content(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param request_body: Inventory Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_remove_tags_serialize(
        self,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/tags/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_swap_event(
        self,
        bulk_swap_event_request: Annotated[BulkSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_swap_event

        Bulk swap event

        :param bulk_swap_event_request: Payload (required)
        :type bulk_swap_event_request: BulkSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_swap_event_serialize(
            bulk_swap_event_request=bulk_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_swap_event_with_http_info(
        self,
        bulk_swap_event_request: Annotated[BulkSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_swap_event

        Bulk swap event

        :param bulk_swap_event_request: Payload (required)
        :type bulk_swap_event_request: BulkSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_swap_event_serialize(
            bulk_swap_event_request=bulk_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_swap_event_without_preload_content(
        self,
        bulk_swap_event_request: Annotated[BulkSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_swap_event

        Bulk swap event

        :param bulk_swap_event_request: Payload (required)
        :type bulk_swap_event_request: BulkSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_swap_event_serialize(
            bulk_swap_event_request=bulk_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_swap_event_serialize(
        self,
        bulk_swap_event_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_swap_event_request is not None:
            _body_params = bulk_swap_event_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/bulk-swap-event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_update(
        self,
        bulk_inventory_update_request: Annotated[BulkInventoryUpdateRequest, Field(description="Bulk inventory attributes to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_update

        Bulk update inventory

        :param bulk_inventory_update_request: Bulk inventory attributes to update (required)
        :type bulk_inventory_update_request: BulkInventoryUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_serialize(
            bulk_inventory_update_request=bulk_inventory_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_update_with_http_info(
        self,
        bulk_inventory_update_request: Annotated[BulkInventoryUpdateRequest, Field(description="Bulk inventory attributes to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_update

        Bulk update inventory

        :param bulk_inventory_update_request: Bulk inventory attributes to update (required)
        :type bulk_inventory_update_request: BulkInventoryUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_serialize(
            bulk_inventory_update_request=bulk_inventory_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_update_without_preload_content(
        self,
        bulk_inventory_update_request: Annotated[BulkInventoryUpdateRequest, Field(description="Bulk inventory attributes to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_update

        Bulk update inventory

        :param bulk_inventory_update_request: Bulk inventory attributes to update (required)
        :type bulk_inventory_update_request: BulkInventoryUpdateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_serialize(
            bulk_inventory_update_request=bulk_inventory_update_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_update_serialize(
        self,
        bulk_inventory_update_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_inventory_update_request is not None:
            _body_params = bulk_inventory_update_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/bulk-update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_update_expected_value(
        self,
        expected_value_update_bulk: Annotated[List[ExpectedValueUpdateBulk], Field(description="Inventory expected value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_update_expected_value

        Bulk Expected Value Update of Inventory

        :param expected_value_update_bulk: Inventory expected value update (required)
        :type expected_value_update_bulk: List[ExpectedValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_expected_value_serialize(
            expected_value_update_bulk=expected_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_update_expected_value_with_http_info(
        self,
        expected_value_update_bulk: Annotated[List[ExpectedValueUpdateBulk], Field(description="Inventory expected value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_update_expected_value

        Bulk Expected Value Update of Inventory

        :param expected_value_update_bulk: Inventory expected value update (required)
        :type expected_value_update_bulk: List[ExpectedValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_expected_value_serialize(
            expected_value_update_bulk=expected_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_update_expected_value_without_preload_content(
        self,
        expected_value_update_bulk: Annotated[List[ExpectedValueUpdateBulk], Field(description="Inventory expected value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_update_expected_value

        Bulk Expected Value Update of Inventory

        :param expected_value_update_bulk: Inventory expected value update (required)
        :type expected_value_update_bulk: List[ExpectedValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_expected_value_serialize(
            expected_value_update_bulk=expected_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_update_expected_value_serialize(
        self,
        expected_value_update_bulk,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ExpectedValueUpdateBulk': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if expected_value_update_bulk is not None:
            _body_params = expected_value_update_bulk



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/bulk-update-expected-value',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_update_face_value(
        self,
        inventory_face_value_update_bulk: Annotated[List[InventoryFaceValueUpdateBulk], Field(description="Inventory face value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_update_face_value

        Bulk Face Value Update of Inventory

        :param inventory_face_value_update_bulk: Inventory face value update (required)
        :type inventory_face_value_update_bulk: List[InventoryFaceValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_face_value_serialize(
            inventory_face_value_update_bulk=inventory_face_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_update_face_value_with_http_info(
        self,
        inventory_face_value_update_bulk: Annotated[List[InventoryFaceValueUpdateBulk], Field(description="Inventory face value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_update_face_value

        Bulk Face Value Update of Inventory

        :param inventory_face_value_update_bulk: Inventory face value update (required)
        :type inventory_face_value_update_bulk: List[InventoryFaceValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_face_value_serialize(
            inventory_face_value_update_bulk=inventory_face_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_update_face_value_without_preload_content(
        self,
        inventory_face_value_update_bulk: Annotated[List[InventoryFaceValueUpdateBulk], Field(description="Inventory face value update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_update_face_value

        Bulk Face Value Update of Inventory

        :param inventory_face_value_update_bulk: Inventory face value update (required)
        :type inventory_face_value_update_bulk: List[InventoryFaceValueUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_face_value_serialize(
            inventory_face_value_update_bulk=inventory_face_value_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_update_face_value_serialize(
        self,
        inventory_face_value_update_bulk,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'InventoryFaceValueUpdateBulk': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inventory_face_value_update_bulk is not None:
            _body_params = inventory_face_value_update_bulk



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/bulk-update-face-value',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_update_price(
        self,
        inventory_price_update_bulk: Annotated[List[InventoryPriceUpdateBulk], Field(description="Inventory price update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_update_price

        Bulk Price Update of Inventory

        :param inventory_price_update_bulk: Inventory price update (required)
        :type inventory_price_update_bulk: List[InventoryPriceUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_price_serialize(
            inventory_price_update_bulk=inventory_price_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_update_price_with_http_info(
        self,
        inventory_price_update_bulk: Annotated[List[InventoryPriceUpdateBulk], Field(description="Inventory price update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_update_price

        Bulk Price Update of Inventory

        :param inventory_price_update_bulk: Inventory price update (required)
        :type inventory_price_update_bulk: List[InventoryPriceUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_price_serialize(
            inventory_price_update_bulk=inventory_price_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_update_price_without_preload_content(
        self,
        inventory_price_update_bulk: Annotated[List[InventoryPriceUpdateBulk], Field(description="Inventory price update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_update_price

        Bulk Price Update of Inventory

        :param inventory_price_update_bulk: Inventory price update (required)
        :type inventory_price_update_bulk: List[InventoryPriceUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_price_serialize(
            inventory_price_update_bulk=inventory_price_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_update_price_serialize(
        self,
        inventory_price_update_bulk,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'InventoryPriceUpdateBulk': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inventory_price_update_bulk is not None:
            _body_params = inventory_price_update_bulk



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_bulk_update_taxed_cost(
        self,
        inventory_taxed_cost_update_bulk: Annotated[List[InventoryTaxedCostUpdateBulk], Field(description="Inventory taxed cost update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_bulk_update_taxed_cost

        Bulk Taxed Cost Update of Inventory

        :param inventory_taxed_cost_update_bulk: Inventory taxed cost update (required)
        :type inventory_taxed_cost_update_bulk: List[InventoryTaxedCostUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_taxed_cost_serialize(
            inventory_taxed_cost_update_bulk=inventory_taxed_cost_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_bulk_update_taxed_cost_with_http_info(
        self,
        inventory_taxed_cost_update_bulk: Annotated[List[InventoryTaxedCostUpdateBulk], Field(description="Inventory taxed cost update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_bulk_update_taxed_cost

        Bulk Taxed Cost Update of Inventory

        :param inventory_taxed_cost_update_bulk: Inventory taxed cost update (required)
        :type inventory_taxed_cost_update_bulk: List[InventoryTaxedCostUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_taxed_cost_serialize(
            inventory_taxed_cost_update_bulk=inventory_taxed_cost_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_bulk_update_taxed_cost_without_preload_content(
        self,
        inventory_taxed_cost_update_bulk: Annotated[List[InventoryTaxedCostUpdateBulk], Field(description="Inventory taxed cost update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_bulk_update_taxed_cost

        Bulk Taxed Cost Update of Inventory

        :param inventory_taxed_cost_update_bulk: Inventory taxed cost update (required)
        :type inventory_taxed_cost_update_bulk: List[InventoryTaxedCostUpdateBulk]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_bulk_update_taxed_cost_serialize(
            inventory_taxed_cost_update_bulk=inventory_taxed_cost_update_bulk,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_bulk_update_taxed_cost_serialize(
        self,
        inventory_taxed_cost_update_bulk,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'InventoryTaxedCostUpdateBulk': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inventory_taxed_cost_update_bulk is not None:
            _body_params = inventory_taxed_cost_update_bulk



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/bulk-taxed-cost-value',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_delete(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The inventory Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_delete

        Deletes tags for an inventory

        :param inventory_id: The inventory Id (required)
        :type inventory_id: int
        :param tag_request: Tags to be removed from the inventory (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_delete_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The inventory Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_delete

        Deletes tags for an inventory

        :param inventory_id: The inventory Id (required)
        :type inventory_id: int
        :param tag_request: Tags to be removed from the inventory (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_delete_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The inventory Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_delete

        Deletes tags for an inventory

        :param inventory_id: The inventory Id (required)
        :type inventory_id: int
        :param tag_request: Tags to be removed from the inventory (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_delete_serialize(
        self,
        inventory_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/{inventory-id}/tags/actions/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_delete_holds_by_id(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory from which to delete holds")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_delete_holds_by_id

        Delete holds for inventory

        :param inventory_id: The ID of the inventory from which to delete holds (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_delete_holds_by_id_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory from which to delete holds")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_delete_holds_by_id

        Delete holds for inventory

        :param inventory_id: The ID of the inventory from which to delete holds (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_delete_holds_by_id_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory from which to delete holds")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_delete_holds_by_id

        Delete holds for inventory

        :param inventory_id: The ID of the inventory from which to delete holds (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_delete_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_delete_holds_by_id_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/inventory/{inventory-id}/hold',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_export(
        self,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InventorySummary]:
        """inventory_export

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_serialize(
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_export_with_http_info(
        self,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InventorySummary]]:
        """inventory_export

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_serialize(
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_export_without_preload_content(
        self,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        version: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_export

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param version:
        :type version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_serialize(
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            version=version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_export_serialize(
        self,
        include_zero_priced_listings,
        include_held,
        include_taxed_costs,
        version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_zero_priced_listings is not None:
            
            _query_params.append(('includeZeroPricedListings', include_zero_priced_listings))
            
        if include_held is not None:
            
            _query_params.append(('includeHeld', include_held))
            
        if include_taxed_costs is not None:
            
            _query_params.append(('includeTaxedCosts', include_taxed_costs))
            
        # process the header parameters
        if version is not None:
            _header_params['Version'] = version
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_export_delta(
        self,
        timestamp: Annotated[Optional[StrictStr], Field(description="Results returned will have newer update timestamps than this value")] = None,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InventorySummary]:
        """inventory_export_delta

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param timestamp: Results returned will have newer update timestamps than this value
        :type timestamp: str
        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_delta_serialize(
            timestamp=timestamp,
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_export_delta_with_http_info(
        self,
        timestamp: Annotated[Optional[StrictStr], Field(description="Results returned will have newer update timestamps than this value")] = None,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InventorySummary]]:
        """inventory_export_delta

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param timestamp: Results returned will have newer update timestamps than this value
        :type timestamp: str
        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_delta_serialize(
            timestamp=timestamp,
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_export_delta_without_preload_content(
        self,
        timestamp: Annotated[Optional[StrictStr], Field(description="Results returned will have newer update timestamps than this value")] = None,
        include_zero_priced_listings: Annotated[Optional[StrictBool], Field(description="Whether the results includes zero price listings")] = None,
        include_held: Annotated[Optional[StrictBool], Field(description="Whether the results includes held")] = None,
        include_taxed_costs: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_export_delta

        Exports inventory for exchange integration. Export is limited to future events with a list price greater than 0. The results from this method are un-sorted.

        :param timestamp: Results returned will have newer update timestamps than this value
        :type timestamp: str
        :param include_zero_priced_listings: Whether the results includes zero price listings
        :type include_zero_priced_listings: bool
        :param include_held: Whether the results includes held
        :type include_held: bool
        :param include_taxed_costs:
        :type include_taxed_costs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_export_delta_serialize(
            timestamp=timestamp,
            include_zero_priced_listings=include_zero_priced_listings,
            include_held=include_held,
            include_taxed_costs=include_taxed_costs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_export_delta_serialize(
        self,
        timestamp,
        include_zero_priced_listings,
        include_held,
        include_taxed_costs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if timestamp is not None:
            
            _query_params.append(('timestamp', timestamp))
            
        if include_zero_priced_listings is not None:
            
            _query_params.append(('includeZeroPricedListings', include_zero_priced_listings))
            
        if include_held is not None:
            
            _query_params.append(('includeHeld', include_held))
            
        if include_taxed_costs is not None:
            
            _query_params.append(('includeTaxedCosts', include_taxed_costs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/export/delta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_get_by_id(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Inventory:
        """inventory_get_by_id

        Get Inventory

        :param inventory_id: The ID of the inventory to return (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_get_by_id_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Inventory]:
        """inventory_get_by_id

        Get Inventory

        :param inventory_id: The ID of the inventory to return (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_get_by_id_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_get_by_id

        Get Inventory

        :param inventory_id: The ID of the inventory to return (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_get_by_id_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/{inventory-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_get_exchanges_pos_id(
        self,
        exchange_pos_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExchangePosIdHistoryResponse:
        """inventory_get_exchanges_pos_id

        Get the history for a exchange pos id

        :param exchange_pos_id: (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_exchanges_pos_id_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangePosIdHistoryResponse",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_get_exchanges_pos_id_with_http_info(
        self,
        exchange_pos_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExchangePosIdHistoryResponse]:
        """inventory_get_exchanges_pos_id

        Get the history for a exchange pos id

        :param exchange_pos_id: (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_exchanges_pos_id_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangePosIdHistoryResponse",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_get_exchanges_pos_id_without_preload_content(
        self,
        exchange_pos_id: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_get_exchanges_pos_id

        Get the history for a exchange pos id

        :param exchange_pos_id: (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_exchanges_pos_id_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangePosIdHistoryResponse",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_get_exchanges_pos_id_serialize(
        self,
        exchange_pos_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if exchange_pos_id is not None:
            _path_params['exchangePosId'] = exchange_pos_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/exchange_pos_id/{exchangePosId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_get_holds_by_id(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return the hold")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Hold:
        """inventory_get_holds_by_id

        Get holds for inventory

        :param inventory_id: The ID of the inventory to return the hold (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Hold",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_get_holds_by_id_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return the hold")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Hold]:
        """inventory_get_holds_by_id

        Get holds for inventory

        :param inventory_id: The ID of the inventory to return the hold (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Hold",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_get_holds_by_id_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to return the hold")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_get_holds_by_id

        Get holds for inventory

        :param inventory_id: The ID of the inventory to return the hold (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_holds_by_id_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Hold",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_get_holds_by_id_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/{inventory-id}/hold',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_get_inventory_barcodes(
        self,
        exchange_pos_id: Annotated[StrictInt, Field(description="The Exchange POS ID of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InventoryBarcodeResponse]:
        """inventory_get_inventory_barcodes

        Get barcodes for inventory

        :param exchange_pos_id: The Exchange POS ID of the inventory (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_barcodes_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryBarcodeResponse]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_get_inventory_barcodes_with_http_info(
        self,
        exchange_pos_id: Annotated[StrictInt, Field(description="The Exchange POS ID of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InventoryBarcodeResponse]]:
        """inventory_get_inventory_barcodes

        Get barcodes for inventory

        :param exchange_pos_id: The Exchange POS ID of the inventory (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_barcodes_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryBarcodeResponse]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_get_inventory_barcodes_without_preload_content(
        self,
        exchange_pos_id: Annotated[StrictInt, Field(description="The Exchange POS ID of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_get_inventory_barcodes

        Get barcodes for inventory

        :param exchange_pos_id: The Exchange POS ID of the inventory (required)
        :type exchange_pos_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_barcodes_serialize(
            exchange_pos_id=exchange_pos_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryBarcodeResponse]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_get_inventory_barcodes_serialize(
        self,
        exchange_pos_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if exchange_pos_id is not None:
            _path_params['exchange-pos-id'] = exchange_pos_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/barcodes/{exchange-pos-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_get_inventory_deltas(
        self,
        start_time: Annotated[StrictStr, Field(description="Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        end_time: Annotated[StrictStr, Field(description="Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        ticket_status: Annotated[Optional[StrictStr], Field(description="Returns inventory updates with requested ticket status.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """inventory_get_inventory_deltas

        Get changed inventory (created, updated, deleted) by update time

        :param start_time: Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type start_time: str
        :param end_time: Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type end_time: str
        :param ticket_status: Returns inventory updates with requested ticket status.
        :type ticket_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_deltas_serialize(
            start_time=start_time,
            end_time=end_time,
            ticket_status=ticket_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_get_inventory_deltas_with_http_info(
        self,
        start_time: Annotated[StrictStr, Field(description="Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        end_time: Annotated[StrictStr, Field(description="Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        ticket_status: Annotated[Optional[StrictStr], Field(description="Returns inventory updates with requested ticket status.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """inventory_get_inventory_deltas

        Get changed inventory (created, updated, deleted) by update time

        :param start_time: Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type start_time: str
        :param end_time: Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type end_time: str
        :param ticket_status: Returns inventory updates with requested ticket status.
        :type ticket_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_deltas_serialize(
            start_time=start_time,
            end_time=end_time,
            ticket_status=ticket_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_get_inventory_deltas_without_preload_content(
        self,
        start_time: Annotated[StrictStr, Field(description="Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        end_time: Annotated[StrictStr, Field(description="Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format.")],
        ticket_status: Annotated[Optional[StrictStr], Field(description="Returns inventory updates with requested ticket status.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_get_inventory_deltas

        Get changed inventory (created, updated, deleted) by update time

        :param start_time: Returns inventory updates after this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type start_time: str
        :param end_time: Returns inventory updates before this time, iso yyyy-MM-ddTHH:mm:ssZ format. (required)
        :type end_time: str
        :param ticket_status: Returns inventory updates with requested ticket status.
        :type ticket_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_get_inventory_deltas_serialize(
            start_time=start_time,
            end_time=end_time,
            ticket_status=ticket_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_get_inventory_deltas_serialize(
        self,
        start_time,
        end_time,
        ticket_status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_time is not None:
            
            _query_params.append(('startTime', start_time))
            
        if end_time is not None:
            
            _query_params.append(('endTime', end_time))
            
        if ticket_status is not None:
            
            _query_params.append(('ticketStatus', ticket_status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/delta',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_legacy_bulk_remove_tags(
        self,
        id: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) inventory_legacy_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param id: Inventory Ids (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/tags is deprecated.", DeprecationWarning)

        _param = self._inventory_legacy_bulk_remove_tags_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_legacy_bulk_remove_tags_with_http_info(
        self,
        id: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) inventory_legacy_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param id: Inventory Ids (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/tags is deprecated.", DeprecationWarning)

        _param = self._inventory_legacy_bulk_remove_tags_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_legacy_bulk_remove_tags_without_preload_content(
        self,
        id: Annotated[List[StrictInt], Field(description="Inventory Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) inventory_legacy_bulk_remove_tags

        Deletes all tags from inventories with given ids

        :param id: Inventory Ids (required)
        :type id: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/tags is deprecated.", DeprecationWarning)

        _param = self._inventory_legacy_bulk_remove_tags_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_legacy_bulk_remove_tags_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'id': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/inventory/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_merge(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Inventory:
        """inventory_merge

        Merge the list of inventories into a new inventory

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_merge_with_http_info(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Inventory]:
        """inventory_merge

        Merge the list of inventories into a new inventory

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_merge_without_preload_content(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_merge

        Merge the list of inventories into a new inventory

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_merge_serialize(
        self,
        merge_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merge_inventory_request is not None:
            _body_params = merge_inventory_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/merge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_merge_as_piggyback(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Inventory:
        """inventory_merge_as_piggyback

        Merge inventories as piggyback

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_as_piggyback_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_merge_as_piggyback_with_http_info(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Inventory]:
        """inventory_merge_as_piggyback

        Merge inventories as piggyback

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_as_piggyback_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_merge_as_piggyback_without_preload_content(
        self,
        merge_inventory_request: Annotated[MergeInventoryRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_merge_as_piggyback

        Merge inventories as piggyback

        :param merge_inventory_request: Payload (required)
        :type merge_inventory_request: MergeInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_merge_as_piggyback_serialize(
            merge_inventory_request=merge_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Inventory",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_merge_as_piggyback_serialize(
        self,
        merge_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if merge_inventory_request is not None:
            _body_params = merge_inventory_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/merge-as-piggyback',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_price_history(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InventoryPriceHistory]:
        """inventory_price_history

        Retrieves price update history for inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_price_history_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryPriceHistory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_price_history_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InventoryPriceHistory]]:
        """inventory_price_history

        Retrieves price update history for inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_price_history_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryPriceHistory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_price_history_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_price_history

        Retrieves price update history for inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_price_history_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventoryPriceHistory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_price_history_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/{inventory-id}/price-history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_remove_tag(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) inventory_remove_tag

        Deletes a tag for an inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag: Tag to be removed from the inventory (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/{inventory-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._inventory_remove_tag_serialize(
            inventory_id=inventory_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_remove_tag_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) inventory_remove_tag

        Deletes a tag for an inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag: Tag to be removed from the inventory (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/{inventory-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._inventory_remove_tag_serialize(
            inventory_id=inventory_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_remove_tag_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the inventory")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) inventory_remove_tag

        Deletes a tag for an inventory

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag: Tag to be removed from the inventory (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /inventory/{inventory-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._inventory_remove_tag_serialize(
            inventory_id=inventory_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_remove_tag_serialize(
        self,
        inventory_id,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        if tag is not None:
            _path_params['tag'] = tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/inventory/{inventory-id}/tags/{tag}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_search(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Primary field to sort by")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        exclude_vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to exclude")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        section_match_mode: Annotated[Optional[StrictStr], Field(description="Section search partial match filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        row_match_mode: Annotated[Optional[StrictStr], Field(description="Row search partial match filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Inventory last update date to range filter")] = None,
        last_price_update_from: Annotated[Optional[datetime], Field(description="Last price update date from range filter")] = None,
        last_price_update_to: Annotated[Optional[datetime], Field(description="Last price update date to range filter")] = None,
        sorted_by_b: Annotated[Optional[StrictStr], Field(description="Secondary field to sort by")] = None,
        sort_dir_b: Annotated[Optional[StrictStr], Field(description="Secondary direction to sort (asc, desc)")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        bar_codes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        external_ticket_id_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have external ticket IDs entered in all tickets")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether the results should have listed inventories")] = None,
        expected_value_set: Annotated[Optional[StrictBool], Field(description="Whether the results should have expected value set")] = None,
        skip_sorting: Annotated[Optional[StrictBool], Field(description="Skip sorting of results")] = None,
        min_quantity: Annotated[Optional[StrictInt], Field(description="Minimum quantity search filter")] = None,
        max_quantity: Annotated[Optional[StrictInt], Field(description="Maximum quantity search filter")] = None,
        min_shown_quantity: Annotated[Optional[StrictInt], Field(description="Minimum shown quantity search filter")] = None,
        max_shown_quantity: Annotated[Optional[StrictInt], Field(description="Maximum shown quantity search filter")] = None,
        min_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum price search filter")] = None,
        max_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum price search filter")] = None,
        min_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum average unit cost search filter")] = None,
        max_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum average unit cost search filter")] = None,
        low_seat: Annotated[Optional[StrictInt], Field(description="Low seat search filter")] = None,
        high_seat: Annotated[Optional[StrictInt], Field(description="High seat search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        include_tickets: Annotated[Optional[StrictBool], Field(description="Whether the results should include tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        seat_type: Annotated[Optional[StrictStr], Field(description="Seat Type search filter")] = None,
        split_type: Annotated[Optional[StrictStr], Field(description="Split Type search filter")] = None,
        no_splits: Annotated[Optional[StrictBool], Field(description="Whether the results should have splits")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        hidden_seats: Annotated[Optional[StrictBool], Field(description="Whether the results should have hidden seats")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a cooperative PO")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        vsr_option: Annotated[Optional[StrictStr], Field(description="VSR option search filter")] = None,
        replenishment_group_id: Annotated[Optional[StrictInt], Field(description="Replenishment group id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a consignment type PO")] = None,
        consignment_status: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a consignment status")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        on_hold: Annotated[Optional[StrictBool], Field(description="Whether the results are on hold")] = None,
        days_old_from: Annotated[Optional[datetime], Field(description="Days Old date from range filter")] = None,
        days_old_to: Annotated[Optional[datetime], Field(description="Days Old date to range filter")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        instant_transfer_status: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a instant transfer status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InventorySummary]:
        """inventory_search

        Get inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Primary field to sort by
        :type sorted_by: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param exclude_vendor_id: Vendor Id to exclude
        :type exclude_vendor_id: int
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param section_match_mode: Section search partial match filter
        :type section_match_mode: str
        :param row: Row search filter
        :type row: str
        :param row_match_mode: Row search partial match filter
        :type row_match_mode: str
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Inventory last update date to range filter
        :type last_update_to: datetime
        :param last_price_update_from: Last price update date from range filter
        :type last_price_update_from: datetime
        :param last_price_update_to: Last price update date to range filter
        :type last_price_update_to: datetime
        :param sorted_by_b: Secondary field to sort by
        :type sorted_by_b: str
        :param sort_dir_b: Secondary direction to sort (asc, desc)
        :type sort_dir_b: str
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param bar_codes_entered: Whether the results should have Bar Codes entered in all tickets
        :type bar_codes_entered: bool
        :param external_ticket_id_entered: Whether the results should have external ticket IDs entered in all tickets
        :type external_ticket_id_entered: bool
        :param listed: Whether the results should have listed inventories
        :type listed: bool
        :param expected_value_set: Whether the results should have expected value set
        :type expected_value_set: bool
        :param skip_sorting: Skip sorting of results
        :type skip_sorting: bool
        :param min_quantity: Minimum quantity search filter
        :type min_quantity: int
        :param max_quantity: Maximum quantity search filter
        :type max_quantity: int
        :param min_shown_quantity: Minimum shown quantity search filter
        :type min_shown_quantity: int
        :param max_shown_quantity: Maximum shown quantity search filter
        :type max_shown_quantity: int
        :param min_price: Minimum price search filter
        :type min_price: float
        :param max_price: Maximum price search filter
        :type max_price: float
        :param min_average_unit_cost: Minimum average unit cost search filter
        :type min_average_unit_cost: float
        :param max_average_unit_cost: Maximum average unit cost search filter
        :type max_average_unit_cost: float
        :param low_seat: Low seat search filter
        :type low_seat: int
        :param high_seat: High seat search filter
        :type high_seat: int
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param notes: Notes search filter
        :type notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param include_tickets: Whether the results should include tickets
        :type include_tickets: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param seat_type: Seat Type search filter
        :type seat_type: str
        :param split_type: Split Type search filter
        :type split_type: str
        :param no_splits: Whether the results should have splits
        :type no_splits: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param hidden_seats: Whether the results should have hidden seats
        :type hidden_seats: bool
        :param cooperative: Whether the results belong to a cooperative PO
        :type cooperative: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param vsr_option: VSR option search filter
        :type vsr_option: str
        :param replenishment_group_id: Replenishment group id search filter
        :type replenishment_group_id: int
        :param consignment: Whether the results belong to a consignment type PO
        :type consignment: str
        :param consignment_status: Whether the results belong to a consignment status
        :type consignment_status: bool
        :param received: Whether the results are received
        :type received: bool
        :param on_hold: Whether the results are on hold
        :type on_hold: bool
        :param days_old_from: Days Old date from range filter
        :type days_old_from: datetime
        :param days_old_to: Days Old date to range filter
        :type days_old_to: datetime
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param instant_transfer_status: Whether the results belong to a instant transfer status
        :type instant_transfer_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            purchase_id=purchase_id,
            exchange_pos_id=exchange_pos_id,
            performer_id=performer_id,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event_tags_match_all=event_tags_match_all,
            event=event,
            event_keywords=event_keywords,
            venue_id=venue_id,
            venue=venue,
            vendor_id=vendor_id,
            exclude_vendor_id=exclude_vendor_id,
            city=city,
            state=state,
            country=country,
            section=section,
            section_match_mode=section_match_mode,
            row=row,
            row_match_mode=row_match_mode,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            event_type=event_type,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            last_price_update_from=last_price_update_from,
            last_price_update_to=last_price_update_to,
            sorted_by_b=sorted_by_b,
            sort_dir_b=sort_dir_b,
            files_uploaded=files_uploaded,
            bar_codes_entered=bar_codes_entered,
            external_ticket_id_entered=external_ticket_id_entered,
            listed=listed,
            expected_value_set=expected_value_set,
            skip_sorting=skip_sorting,
            min_quantity=min_quantity,
            max_quantity=max_quantity,
            min_shown_quantity=min_shown_quantity,
            max_shown_quantity=max_shown_quantity,
            min_price=min_price,
            max_price=max_price,
            min_average_unit_cost=min_average_unit_cost,
            max_average_unit_cost=max_average_unit_cost,
            low_seat=low_seat,
            high_seat=high_seat,
            in_hand=in_hand,
            notes=notes,
            public_notes=public_notes,
            no_tags=no_tags,
            include_tickets=include_tickets,
            zone_seating=zone_seating,
            day_of_week=day_of_week,
            seat_type=seat_type,
            split_type=split_type,
            no_splits=no_splits,
            currency_code=currency_code,
            hidden_seats=hidden_seats,
            cooperative=cooperative,
            electronic_transfer=electronic_transfer,
            vsr_option=vsr_option,
            replenishment_group_id=replenishment_group_id,
            consignment=consignment,
            consignment_status=consignment_status,
            received=received,
            on_hold=on_hold,
            days_old_from=days_old_from,
            days_old_to=days_old_to,
            exclude_parking=exclude_parking,
            instant_transfer_status=instant_transfer_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_search_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Primary field to sort by")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        exclude_vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to exclude")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        section_match_mode: Annotated[Optional[StrictStr], Field(description="Section search partial match filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        row_match_mode: Annotated[Optional[StrictStr], Field(description="Row search partial match filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Inventory last update date to range filter")] = None,
        last_price_update_from: Annotated[Optional[datetime], Field(description="Last price update date from range filter")] = None,
        last_price_update_to: Annotated[Optional[datetime], Field(description="Last price update date to range filter")] = None,
        sorted_by_b: Annotated[Optional[StrictStr], Field(description="Secondary field to sort by")] = None,
        sort_dir_b: Annotated[Optional[StrictStr], Field(description="Secondary direction to sort (asc, desc)")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        bar_codes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        external_ticket_id_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have external ticket IDs entered in all tickets")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether the results should have listed inventories")] = None,
        expected_value_set: Annotated[Optional[StrictBool], Field(description="Whether the results should have expected value set")] = None,
        skip_sorting: Annotated[Optional[StrictBool], Field(description="Skip sorting of results")] = None,
        min_quantity: Annotated[Optional[StrictInt], Field(description="Minimum quantity search filter")] = None,
        max_quantity: Annotated[Optional[StrictInt], Field(description="Maximum quantity search filter")] = None,
        min_shown_quantity: Annotated[Optional[StrictInt], Field(description="Minimum shown quantity search filter")] = None,
        max_shown_quantity: Annotated[Optional[StrictInt], Field(description="Maximum shown quantity search filter")] = None,
        min_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum price search filter")] = None,
        max_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum price search filter")] = None,
        min_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum average unit cost search filter")] = None,
        max_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum average unit cost search filter")] = None,
        low_seat: Annotated[Optional[StrictInt], Field(description="Low seat search filter")] = None,
        high_seat: Annotated[Optional[StrictInt], Field(description="High seat search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        include_tickets: Annotated[Optional[StrictBool], Field(description="Whether the results should include tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        seat_type: Annotated[Optional[StrictStr], Field(description="Seat Type search filter")] = None,
        split_type: Annotated[Optional[StrictStr], Field(description="Split Type search filter")] = None,
        no_splits: Annotated[Optional[StrictBool], Field(description="Whether the results should have splits")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        hidden_seats: Annotated[Optional[StrictBool], Field(description="Whether the results should have hidden seats")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a cooperative PO")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        vsr_option: Annotated[Optional[StrictStr], Field(description="VSR option search filter")] = None,
        replenishment_group_id: Annotated[Optional[StrictInt], Field(description="Replenishment group id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a consignment type PO")] = None,
        consignment_status: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a consignment status")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        on_hold: Annotated[Optional[StrictBool], Field(description="Whether the results are on hold")] = None,
        days_old_from: Annotated[Optional[datetime], Field(description="Days Old date from range filter")] = None,
        days_old_to: Annotated[Optional[datetime], Field(description="Days Old date to range filter")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        instant_transfer_status: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a instant transfer status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InventorySummary]]:
        """inventory_search

        Get inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Primary field to sort by
        :type sorted_by: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param exclude_vendor_id: Vendor Id to exclude
        :type exclude_vendor_id: int
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param section_match_mode: Section search partial match filter
        :type section_match_mode: str
        :param row: Row search filter
        :type row: str
        :param row_match_mode: Row search partial match filter
        :type row_match_mode: str
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Inventory last update date to range filter
        :type last_update_to: datetime
        :param last_price_update_from: Last price update date from range filter
        :type last_price_update_from: datetime
        :param last_price_update_to: Last price update date to range filter
        :type last_price_update_to: datetime
        :param sorted_by_b: Secondary field to sort by
        :type sorted_by_b: str
        :param sort_dir_b: Secondary direction to sort (asc, desc)
        :type sort_dir_b: str
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param bar_codes_entered: Whether the results should have Bar Codes entered in all tickets
        :type bar_codes_entered: bool
        :param external_ticket_id_entered: Whether the results should have external ticket IDs entered in all tickets
        :type external_ticket_id_entered: bool
        :param listed: Whether the results should have listed inventories
        :type listed: bool
        :param expected_value_set: Whether the results should have expected value set
        :type expected_value_set: bool
        :param skip_sorting: Skip sorting of results
        :type skip_sorting: bool
        :param min_quantity: Minimum quantity search filter
        :type min_quantity: int
        :param max_quantity: Maximum quantity search filter
        :type max_quantity: int
        :param min_shown_quantity: Minimum shown quantity search filter
        :type min_shown_quantity: int
        :param max_shown_quantity: Maximum shown quantity search filter
        :type max_shown_quantity: int
        :param min_price: Minimum price search filter
        :type min_price: float
        :param max_price: Maximum price search filter
        :type max_price: float
        :param min_average_unit_cost: Minimum average unit cost search filter
        :type min_average_unit_cost: float
        :param max_average_unit_cost: Maximum average unit cost search filter
        :type max_average_unit_cost: float
        :param low_seat: Low seat search filter
        :type low_seat: int
        :param high_seat: High seat search filter
        :type high_seat: int
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param notes: Notes search filter
        :type notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param include_tickets: Whether the results should include tickets
        :type include_tickets: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param seat_type: Seat Type search filter
        :type seat_type: str
        :param split_type: Split Type search filter
        :type split_type: str
        :param no_splits: Whether the results should have splits
        :type no_splits: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param hidden_seats: Whether the results should have hidden seats
        :type hidden_seats: bool
        :param cooperative: Whether the results belong to a cooperative PO
        :type cooperative: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param vsr_option: VSR option search filter
        :type vsr_option: str
        :param replenishment_group_id: Replenishment group id search filter
        :type replenishment_group_id: int
        :param consignment: Whether the results belong to a consignment type PO
        :type consignment: str
        :param consignment_status: Whether the results belong to a consignment status
        :type consignment_status: bool
        :param received: Whether the results are received
        :type received: bool
        :param on_hold: Whether the results are on hold
        :type on_hold: bool
        :param days_old_from: Days Old date from range filter
        :type days_old_from: datetime
        :param days_old_to: Days Old date to range filter
        :type days_old_to: datetime
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param instant_transfer_status: Whether the results belong to a instant transfer status
        :type instant_transfer_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            purchase_id=purchase_id,
            exchange_pos_id=exchange_pos_id,
            performer_id=performer_id,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event_tags_match_all=event_tags_match_all,
            event=event,
            event_keywords=event_keywords,
            venue_id=venue_id,
            venue=venue,
            vendor_id=vendor_id,
            exclude_vendor_id=exclude_vendor_id,
            city=city,
            state=state,
            country=country,
            section=section,
            section_match_mode=section_match_mode,
            row=row,
            row_match_mode=row_match_mode,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            event_type=event_type,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            last_price_update_from=last_price_update_from,
            last_price_update_to=last_price_update_to,
            sorted_by_b=sorted_by_b,
            sort_dir_b=sort_dir_b,
            files_uploaded=files_uploaded,
            bar_codes_entered=bar_codes_entered,
            external_ticket_id_entered=external_ticket_id_entered,
            listed=listed,
            expected_value_set=expected_value_set,
            skip_sorting=skip_sorting,
            min_quantity=min_quantity,
            max_quantity=max_quantity,
            min_shown_quantity=min_shown_quantity,
            max_shown_quantity=max_shown_quantity,
            min_price=min_price,
            max_price=max_price,
            min_average_unit_cost=min_average_unit_cost,
            max_average_unit_cost=max_average_unit_cost,
            low_seat=low_seat,
            high_seat=high_seat,
            in_hand=in_hand,
            notes=notes,
            public_notes=public_notes,
            no_tags=no_tags,
            include_tickets=include_tickets,
            zone_seating=zone_seating,
            day_of_week=day_of_week,
            seat_type=seat_type,
            split_type=split_type,
            no_splits=no_splits,
            currency_code=currency_code,
            hidden_seats=hidden_seats,
            cooperative=cooperative,
            electronic_transfer=electronic_transfer,
            vsr_option=vsr_option,
            replenishment_group_id=replenishment_group_id,
            consignment=consignment,
            consignment_status=consignment_status,
            received=received,
            on_hold=on_hold,
            days_old_from=days_old_from,
            days_old_to=days_old_to,
            exclude_parking=exclude_parking,
            instant_transfer_status=instant_transfer_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_search_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Primary field to sort by")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        exclude_vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to exclude")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        section_match_mode: Annotated[Optional[StrictStr], Field(description="Section search partial match filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        row_match_mode: Annotated[Optional[StrictStr], Field(description="Row search partial match filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Inventory last update date to range filter")] = None,
        last_price_update_from: Annotated[Optional[datetime], Field(description="Last price update date from range filter")] = None,
        last_price_update_to: Annotated[Optional[datetime], Field(description="Last price update date to range filter")] = None,
        sorted_by_b: Annotated[Optional[StrictStr], Field(description="Secondary field to sort by")] = None,
        sort_dir_b: Annotated[Optional[StrictStr], Field(description="Secondary direction to sort (asc, desc)")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        bar_codes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        external_ticket_id_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have external ticket IDs entered in all tickets")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether the results should have listed inventories")] = None,
        expected_value_set: Annotated[Optional[StrictBool], Field(description="Whether the results should have expected value set")] = None,
        skip_sorting: Annotated[Optional[StrictBool], Field(description="Skip sorting of results")] = None,
        min_quantity: Annotated[Optional[StrictInt], Field(description="Minimum quantity search filter")] = None,
        max_quantity: Annotated[Optional[StrictInt], Field(description="Maximum quantity search filter")] = None,
        min_shown_quantity: Annotated[Optional[StrictInt], Field(description="Minimum shown quantity search filter")] = None,
        max_shown_quantity: Annotated[Optional[StrictInt], Field(description="Maximum shown quantity search filter")] = None,
        min_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum price search filter")] = None,
        max_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum price search filter")] = None,
        min_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum average unit cost search filter")] = None,
        max_average_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum average unit cost search filter")] = None,
        low_seat: Annotated[Optional[StrictInt], Field(description="Low seat search filter")] = None,
        high_seat: Annotated[Optional[StrictInt], Field(description="High seat search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        include_tickets: Annotated[Optional[StrictBool], Field(description="Whether the results should include tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        seat_type: Annotated[Optional[StrictStr], Field(description="Seat Type search filter")] = None,
        split_type: Annotated[Optional[StrictStr], Field(description="Split Type search filter")] = None,
        no_splits: Annotated[Optional[StrictBool], Field(description="Whether the results should have splits")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        hidden_seats: Annotated[Optional[StrictBool], Field(description="Whether the results should have hidden seats")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a cooperative PO")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        vsr_option: Annotated[Optional[StrictStr], Field(description="VSR option search filter")] = None,
        replenishment_group_id: Annotated[Optional[StrictInt], Field(description="Replenishment group id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a consignment type PO")] = None,
        consignment_status: Annotated[Optional[StrictBool], Field(description="Whether the results belong to a consignment status")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        on_hold: Annotated[Optional[StrictBool], Field(description="Whether the results are on hold")] = None,
        days_old_from: Annotated[Optional[datetime], Field(description="Days Old date from range filter")] = None,
        days_old_to: Annotated[Optional[datetime], Field(description="Days Old date to range filter")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        instant_transfer_status: Annotated[Optional[StrictStr], Field(description="Whether the results belong to a instant transfer status")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_search

        Get inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Primary field to sort by
        :type sorted_by: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param exclude_vendor_id: Vendor Id to exclude
        :type exclude_vendor_id: int
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param section_match_mode: Section search partial match filter
        :type section_match_mode: str
        :param row: Row search filter
        :type row: str
        :param row_match_mode: Row search partial match filter
        :type row_match_mode: str
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Inventory last update date to range filter
        :type last_update_to: datetime
        :param last_price_update_from: Last price update date from range filter
        :type last_price_update_from: datetime
        :param last_price_update_to: Last price update date to range filter
        :type last_price_update_to: datetime
        :param sorted_by_b: Secondary field to sort by
        :type sorted_by_b: str
        :param sort_dir_b: Secondary direction to sort (asc, desc)
        :type sort_dir_b: str
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param bar_codes_entered: Whether the results should have Bar Codes entered in all tickets
        :type bar_codes_entered: bool
        :param external_ticket_id_entered: Whether the results should have external ticket IDs entered in all tickets
        :type external_ticket_id_entered: bool
        :param listed: Whether the results should have listed inventories
        :type listed: bool
        :param expected_value_set: Whether the results should have expected value set
        :type expected_value_set: bool
        :param skip_sorting: Skip sorting of results
        :type skip_sorting: bool
        :param min_quantity: Minimum quantity search filter
        :type min_quantity: int
        :param max_quantity: Maximum quantity search filter
        :type max_quantity: int
        :param min_shown_quantity: Minimum shown quantity search filter
        :type min_shown_quantity: int
        :param max_shown_quantity: Maximum shown quantity search filter
        :type max_shown_quantity: int
        :param min_price: Minimum price search filter
        :type min_price: float
        :param max_price: Maximum price search filter
        :type max_price: float
        :param min_average_unit_cost: Minimum average unit cost search filter
        :type min_average_unit_cost: float
        :param max_average_unit_cost: Maximum average unit cost search filter
        :type max_average_unit_cost: float
        :param low_seat: Low seat search filter
        :type low_seat: int
        :param high_seat: High seat search filter
        :type high_seat: int
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param notes: Notes search filter
        :type notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param include_tickets: Whether the results should include tickets
        :type include_tickets: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param seat_type: Seat Type search filter
        :type seat_type: str
        :param split_type: Split Type search filter
        :type split_type: str
        :param no_splits: Whether the results should have splits
        :type no_splits: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param hidden_seats: Whether the results should have hidden seats
        :type hidden_seats: bool
        :param cooperative: Whether the results belong to a cooperative PO
        :type cooperative: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param vsr_option: VSR option search filter
        :type vsr_option: str
        :param replenishment_group_id: Replenishment group id search filter
        :type replenishment_group_id: int
        :param consignment: Whether the results belong to a consignment type PO
        :type consignment: str
        :param consignment_status: Whether the results belong to a consignment status
        :type consignment_status: bool
        :param received: Whether the results are received
        :type received: bool
        :param on_hold: Whether the results are on hold
        :type on_hold: bool
        :param days_old_from: Days Old date from range filter
        :type days_old_from: datetime
        :param days_old_to: Days Old date to range filter
        :type days_old_to: datetime
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param instant_transfer_status: Whether the results belong to a instant transfer status
        :type instant_transfer_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            purchase_id=purchase_id,
            exchange_pos_id=exchange_pos_id,
            performer_id=performer_id,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event_tags_match_all=event_tags_match_all,
            event=event,
            event_keywords=event_keywords,
            venue_id=venue_id,
            venue=venue,
            vendor_id=vendor_id,
            exclude_vendor_id=exclude_vendor_id,
            city=city,
            state=state,
            country=country,
            section=section,
            section_match_mode=section_match_mode,
            row=row,
            row_match_mode=row_match_mode,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            event_type=event_type,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            last_price_update_from=last_price_update_from,
            last_price_update_to=last_price_update_to,
            sorted_by_b=sorted_by_b,
            sort_dir_b=sort_dir_b,
            files_uploaded=files_uploaded,
            bar_codes_entered=bar_codes_entered,
            external_ticket_id_entered=external_ticket_id_entered,
            listed=listed,
            expected_value_set=expected_value_set,
            skip_sorting=skip_sorting,
            min_quantity=min_quantity,
            max_quantity=max_quantity,
            min_shown_quantity=min_shown_quantity,
            max_shown_quantity=max_shown_quantity,
            min_price=min_price,
            max_price=max_price,
            min_average_unit_cost=min_average_unit_cost,
            max_average_unit_cost=max_average_unit_cost,
            low_seat=low_seat,
            high_seat=high_seat,
            in_hand=in_hand,
            notes=notes,
            public_notes=public_notes,
            no_tags=no_tags,
            include_tickets=include_tickets,
            zone_seating=zone_seating,
            day_of_week=day_of_week,
            seat_type=seat_type,
            split_type=split_type,
            no_splits=no_splits,
            currency_code=currency_code,
            hidden_seats=hidden_seats,
            cooperative=cooperative,
            electronic_transfer=electronic_transfer,
            vsr_option=vsr_option,
            replenishment_group_id=replenishment_group_id,
            consignment=consignment,
            consignment_status=consignment_status,
            received=received,
            on_hold=on_hold,
            days_old_from=days_old_from,
            days_old_to=days_old_to,
            exclude_parking=exclude_parking,
            instant_transfer_status=instant_transfer_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_search_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        sorted_by,
        stock_type,
        ticket_status,
        event_id,
        inventory_id,
        purchase_id,
        exchange_pos_id,
        performer_id,
        category_id,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        event_tags_match_all,
        event,
        event_keywords,
        venue_id,
        venue,
        vendor_id,
        exclude_vendor_id,
        city,
        state,
        country,
        section,
        section_match_mode,
        row,
        row_match_mode,
        event_date_from,
        event_date_to,
        event_time_from,
        event_time_to,
        event_type,
        purchase_date_from,
        purchase_date_to,
        last_update_from,
        last_update_to,
        last_price_update_from,
        last_price_update_to,
        sorted_by_b,
        sort_dir_b,
        files_uploaded,
        bar_codes_entered,
        external_ticket_id_entered,
        listed,
        expected_value_set,
        skip_sorting,
        min_quantity,
        max_quantity,
        min_shown_quantity,
        max_shown_quantity,
        min_price,
        max_price,
        min_average_unit_cost,
        max_average_unit_cost,
        low_seat,
        high_seat,
        in_hand,
        notes,
        public_notes,
        no_tags,
        include_tickets,
        zone_seating,
        day_of_week,
        seat_type,
        split_type,
        no_splits,
        currency_code,
        hidden_seats,
        cooperative,
        electronic_transfer,
        vsr_option,
        replenishment_group_id,
        consignment,
        consignment_status,
        received,
        on_hold,
        days_old_from,
        days_old_to,
        exclude_parking,
        instant_transfer_status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ticketStatus': 'multi',
            'eventId': 'multi',
            'inventoryId': 'multi',
            'purchaseId': 'multi',
            'exchangePosId': 'multi',
            'performerId': 'multi',
            'categoryId': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'eventKeywords': 'multi',
            'state': 'multi',
            'country': 'multi',
            'dayOfWeek': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        if stock_type is not None:
            
            _query_params.append(('stockType', stock_type))
            
        if ticket_status is not None:
            
            _query_params.append(('ticketStatus', ticket_status))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if inventory_id is not None:
            
            _query_params.append(('inventoryId', inventory_id))
            
        if purchase_id is not None:
            
            _query_params.append(('purchaseId', purchase_id))
            
        if exchange_pos_id is not None:
            
            _query_params.append(('exchangePosId', exchange_pos_id))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if event_tags_match_all is not None:
            
            _query_params.append(('eventTagsMatchAll', event_tags_match_all))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if event_keywords is not None:
            
            _query_params.append(('eventKeywords', event_keywords))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if exclude_vendor_id is not None:
            
            _query_params.append(('excludeVendorId', exclude_vendor_id))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if section_match_mode is not None:
            
            _query_params.append(('sectionMatchMode', section_match_mode))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if row_match_mode is not None:
            
            _query_params.append(('rowMatchMode', row_match_mode))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if event_time_from is not None:
            
            _query_params.append(('eventTimeFrom', event_time_from))
            
        if event_time_to is not None:
            
            _query_params.append(('eventTimeTo', event_time_to))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if purchase_date_from is not None:
            if isinstance(purchase_date_from, datetime):
                _query_params.append(
                    (
                        'purchaseDateFrom',
                        purchase_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateFrom', purchase_date_from))
            
        if purchase_date_to is not None:
            if isinstance(purchase_date_to, datetime):
                _query_params.append(
                    (
                        'purchaseDateTo',
                        purchase_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateTo', purchase_date_to))
            
        if last_update_from is not None:
            if isinstance(last_update_from, datetime):
                _query_params.append(
                    (
                        'lastUpdateFrom',
                        last_update_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateFrom', last_update_from))
            
        if last_update_to is not None:
            if isinstance(last_update_to, datetime):
                _query_params.append(
                    (
                        'lastUpdateTo',
                        last_update_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateTo', last_update_to))
            
        if last_price_update_from is not None:
            if isinstance(last_price_update_from, datetime):
                _query_params.append(
                    (
                        'lastPriceUpdateFrom',
                        last_price_update_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastPriceUpdateFrom', last_price_update_from))
            
        if last_price_update_to is not None:
            if isinstance(last_price_update_to, datetime):
                _query_params.append(
                    (
                        'lastPriceUpdateTo',
                        last_price_update_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastPriceUpdateTo', last_price_update_to))
            
        if sorted_by_b is not None:
            
            _query_params.append(('sortedByB', sorted_by_b))
            
        if sort_dir_b is not None:
            
            _query_params.append(('sortDirB', sort_dir_b))
            
        if files_uploaded is not None:
            
            _query_params.append(('filesUploaded', files_uploaded))
            
        if bar_codes_entered is not None:
            
            _query_params.append(('barCodesEntered', bar_codes_entered))
            
        if external_ticket_id_entered is not None:
            
            _query_params.append(('externalTicketIdEntered', external_ticket_id_entered))
            
        if listed is not None:
            
            _query_params.append(('listed', listed))
            
        if expected_value_set is not None:
            
            _query_params.append(('expectedValueSet', expected_value_set))
            
        if skip_sorting is not None:
            
            _query_params.append(('skipSorting', skip_sorting))
            
        if min_quantity is not None:
            
            _query_params.append(('minQuantity', min_quantity))
            
        if max_quantity is not None:
            
            _query_params.append(('maxQuantity', max_quantity))
            
        if min_shown_quantity is not None:
            
            _query_params.append(('minShownQuantity', min_shown_quantity))
            
        if max_shown_quantity is not None:
            
            _query_params.append(('maxShownQuantity', max_shown_quantity))
            
        if min_price is not None:
            
            _query_params.append(('minPrice', min_price))
            
        if max_price is not None:
            
            _query_params.append(('maxPrice', max_price))
            
        if min_average_unit_cost is not None:
            
            _query_params.append(('minAverageUnitCost', min_average_unit_cost))
            
        if max_average_unit_cost is not None:
            
            _query_params.append(('maxAverageUnitCost', max_average_unit_cost))
            
        if low_seat is not None:
            
            _query_params.append(('lowSeat', low_seat))
            
        if high_seat is not None:
            
            _query_params.append(('highSeat', high_seat))
            
        if in_hand is not None:
            
            _query_params.append(('inHand', in_hand))
            
        if notes is not None:
            
            _query_params.append(('notes', notes))
            
        if public_notes is not None:
            
            _query_params.append(('publicNotes', public_notes))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if include_tickets is not None:
            
            _query_params.append(('includeTickets', include_tickets))
            
        if zone_seating is not None:
            
            _query_params.append(('zoneSeating', zone_seating))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if seat_type is not None:
            
            _query_params.append(('seatType', seat_type))
            
        if split_type is not None:
            
            _query_params.append(('splitType', split_type))
            
        if no_splits is not None:
            
            _query_params.append(('noSplits', no_splits))
            
        if currency_code is not None:
            
            _query_params.append(('currencyCode', currency_code))
            
        if hidden_seats is not None:
            
            _query_params.append(('hiddenSeats', hidden_seats))
            
        if cooperative is not None:
            
            _query_params.append(('cooperative', cooperative))
            
        if electronic_transfer is not None:
            
            _query_params.append(('electronicTransfer', electronic_transfer))
            
        if vsr_option is not None:
            
            _query_params.append(('vsrOption', vsr_option))
            
        if replenishment_group_id is not None:
            
            _query_params.append(('replenishmentGroupId', replenishment_group_id))
            
        if consignment is not None:
            
            _query_params.append(('consignment', consignment))
            
        if consignment_status is not None:
            
            _query_params.append(('consignmentStatus', consignment_status))
            
        if received is not None:
            
            _query_params.append(('received', received))
            
        if on_hold is not None:
            
            _query_params.append(('onHold', on_hold))
            
        if days_old_from is not None:
            if isinstance(days_old_from, datetime):
                _query_params.append(
                    (
                        'daysOldFrom',
                        days_old_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('daysOldFrom', days_old_from))
            
        if days_old_to is not None:
            if isinstance(days_old_to, datetime):
                _query_params.append(
                    (
                        'daysOldTo',
                        days_old_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('daysOldTo', days_old_to))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if instant_transfer_status is not None:
            
            _query_params.append(('instantTransferStatus', instant_transfer_status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_search_purchased(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PurchasedInventorySummary]:
        """inventory_search_purchased

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_search_purchased_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PurchasedInventorySummary]]:
        """inventory_search_purchased

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_search_purchased_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_search_purchased

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_search_purchased_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        stock_type,
        ticket_status,
        event_id,
        inventory_id,
        performer_id,
        vendor_id,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        event,
        venue,
        city,
        state,
        country,
        section,
        row,
        purchase_date_from,
        purchase_date_to,
        event_date_from,
        event_date_to,
        external_ref,
        payment_status,
        partial_payment_ref,
        display_name,
        zone_seating,
        notes,
        performer,
        purchase_id,
        in_hand_date_from,
        in_hand_date_to,
        received,
        venue_ids,
        consignment,
        cooperative,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ticketStatus': 'multi',
            'eventId': 'multi',
            'inventoryId': 'multi',
            'performerId': 'multi',
            'vendorId': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'state': 'multi',
            'country': 'multi',
            'paymentStatus': 'multi',
            'purchaseId': 'multi',
            'venueIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if stock_type is not None:
            
            _query_params.append(('stockType', stock_type))
            
        if ticket_status is not None:
            
            _query_params.append(('ticketStatus', ticket_status))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if inventory_id is not None:
            
            _query_params.append(('inventoryId', inventory_id))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if purchase_date_from is not None:
            if isinstance(purchase_date_from, datetime):
                _query_params.append(
                    (
                        'purchaseDateFrom',
                        purchase_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateFrom', purchase_date_from))
            
        if purchase_date_to is not None:
            if isinstance(purchase_date_to, datetime):
                _query_params.append(
                    (
                        'purchaseDateTo',
                        purchase_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateTo', purchase_date_to))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if partial_payment_ref is not None:
            
            _query_params.append(('partialPaymentRef', partial_payment_ref))
            
        if display_name is not None:
            
            _query_params.append(('displayName', display_name))
            
        if zone_seating is not None:
            
            _query_params.append(('zoneSeating', zone_seating))
            
        if notes is not None:
            
            _query_params.append(('notes', notes))
            
        if performer is not None:
            
            _query_params.append(('performer', performer))
            
        if purchase_id is not None:
            
            _query_params.append(('purchaseId', purchase_id))
            
        if in_hand_date_from is not None:
            if isinstance(in_hand_date_from, datetime):
                _query_params.append(
                    (
                        'inHandDateFrom',
                        in_hand_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateFrom', in_hand_date_from))
            
        if in_hand_date_to is not None:
            if isinstance(in_hand_date_to, datetime):
                _query_params.append(
                    (
                        'inHandDateTo',
                        in_hand_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateTo', in_hand_date_to))
            
        if received is not None:
            
            _query_params.append(('received', received))
            
        if venue_ids is not None:
            
            _query_params.append(('venueIds', venue_ids))
            
        if consignment is not None:
            
            _query_params.append(('consignment', consignment))
            
        if cooperative is not None:
            
            _query_params.append(('cooperative', cooperative))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/purchased',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_search_purchased_v2(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        credit_card_group_id: Annotated[Optional[StrictInt], Field(description="Credit card group id search filter")] = None,
        credit_card_last_digits: Annotated[Optional[StrictStr], Field(description="Credit card last digits search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        anti_inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to exclude")] = None,
        anti_inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have inventory tags")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment method search filter")] = None,
        min_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum unit cost search filter")] = None,
        max_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum unit cost search filter")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for PO creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Performer category search filter")] = None,
        last_purchase_order_note: Annotated[Optional[StrictStr], Field(description="Last purchase order note")] = None,
        inventory_public_notes: Annotated[Optional[StrictStr], Field(description="Inventory public notes")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PurchasedInventorySummaryV2]:
        """inventory_search_purchased_v2

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param credit_card_group_id: Credit card group id search filter
        :type credit_card_group_id: int
        :param credit_card_last_digits: Credit card last digits search filter
        :type credit_card_last_digits: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param anti_inventory_tag: Inventory tags to exclude
        :type anti_inventory_tag: List[str]
        :param anti_inventory_tags_match_all: Whether the results should not have all inventory tags or only some
        :type anti_inventory_tags_match_all: bool
        :param no_tags: Whether the results should have inventory tags
        :type no_tags: bool
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param payment_method: Payment method search filter
        :type payment_method: str
        :param min_unit_cost: Minimum unit cost search filter
        :type min_unit_cost: float
        :param max_unit_cost: Maximum unit cost search filter
        :type max_unit_cost: float
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param created_by: Email search filter for PO creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param currency_code: Currency filter
        :type currency_code: str
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param category_id: Performer category search filter
        :type category_id: List[int]
        :param last_purchase_order_note: Last purchase order note
        :type last_purchase_order_note: str
        :param inventory_public_notes: Inventory public notes
        :type inventory_public_notes: str
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_v2_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            credit_card_group_id=credit_card_group_id,
            credit_card_last_digits=credit_card_last_digits,
            event_type=event_type,
            in_hand=in_hand,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            anti_inventory_tag=anti_inventory_tag,
            anti_inventory_tags_match_all=anti_inventory_tags_match_all,
            no_tags=no_tags,
            includes_seat=includes_seat,
            payment_method=payment_method,
            min_unit_cost=min_unit_cost,
            max_unit_cost=max_unit_cost,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            currency_code=currency_code,
            purchase_status=purchase_status,
            category_id=category_id,
            last_purchase_order_note=last_purchase_order_note,
            inventory_public_notes=inventory_public_notes,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummaryV2]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_search_purchased_v2_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        credit_card_group_id: Annotated[Optional[StrictInt], Field(description="Credit card group id search filter")] = None,
        credit_card_last_digits: Annotated[Optional[StrictStr], Field(description="Credit card last digits search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        anti_inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to exclude")] = None,
        anti_inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have inventory tags")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment method search filter")] = None,
        min_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum unit cost search filter")] = None,
        max_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum unit cost search filter")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for PO creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Performer category search filter")] = None,
        last_purchase_order_note: Annotated[Optional[StrictStr], Field(description="Last purchase order note")] = None,
        inventory_public_notes: Annotated[Optional[StrictStr], Field(description="Inventory public notes")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PurchasedInventorySummaryV2]]:
        """inventory_search_purchased_v2

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param credit_card_group_id: Credit card group id search filter
        :type credit_card_group_id: int
        :param credit_card_last_digits: Credit card last digits search filter
        :type credit_card_last_digits: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param anti_inventory_tag: Inventory tags to exclude
        :type anti_inventory_tag: List[str]
        :param anti_inventory_tags_match_all: Whether the results should not have all inventory tags or only some
        :type anti_inventory_tags_match_all: bool
        :param no_tags: Whether the results should have inventory tags
        :type no_tags: bool
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param payment_method: Payment method search filter
        :type payment_method: str
        :param min_unit_cost: Minimum unit cost search filter
        :type min_unit_cost: float
        :param max_unit_cost: Maximum unit cost search filter
        :type max_unit_cost: float
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param created_by: Email search filter for PO creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param currency_code: Currency filter
        :type currency_code: str
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param category_id: Performer category search filter
        :type category_id: List[int]
        :param last_purchase_order_note: Last purchase order note
        :type last_purchase_order_note: str
        :param inventory_public_notes: Inventory public notes
        :type inventory_public_notes: str
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_v2_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            credit_card_group_id=credit_card_group_id,
            credit_card_last_digits=credit_card_last_digits,
            event_type=event_type,
            in_hand=in_hand,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            anti_inventory_tag=anti_inventory_tag,
            anti_inventory_tags_match_all=anti_inventory_tags_match_all,
            no_tags=no_tags,
            includes_seat=includes_seat,
            payment_method=payment_method,
            min_unit_cost=min_unit_cost,
            max_unit_cost=max_unit_cost,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            currency_code=currency_code,
            purchase_status=purchase_status,
            category_id=category_id,
            last_purchase_order_note=last_purchase_order_note,
            inventory_public_notes=inventory_public_notes,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummaryV2]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_search_purchased_v2_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        ticket_status: Annotated[Optional[List[StrictStr]], Field(description="Ticket Status search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id search filter")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all PO tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="PO tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all PO tags or only some")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        partial_payment_ref: Annotated[Optional[StrictStr], Field(description="Partial payment reference search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        notes: Annotated[Optional[StrictStr], Field(description="Notes search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        purchase_id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results have received POs")] = None,
        venue_ids: Annotated[Optional[List[StrictInt]], Field(description="Venue id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        credit_card_group_id: Annotated[Optional[StrictInt], Field(description="Credit card group id search filter")] = None,
        credit_card_last_digits: Annotated[Optional[StrictStr], Field(description="Credit card last digits search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        in_hand: Annotated[Optional[StrictBool], Field(description="Whether the results should be in hand")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        anti_inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to exclude")] = None,
        anti_inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have inventory tags")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        payment_method: Annotated[Optional[StrictStr], Field(description="Payment method search filter")] = None,
        min_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum unit cost search filter")] = None,
        max_unit_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum unit cost search filter")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for PO creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Performer category search filter")] = None,
        last_purchase_order_note: Annotated[Optional[StrictStr], Field(description="Last purchase order note")] = None,
        inventory_public_notes: Annotated[Optional[StrictStr], Field(description="Inventory public notes")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_search_purchased_v2

        Gets purchased inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: List[str]
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: List[int]
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param tag: Purchase tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all PO tags or only some
        :type tags_match_all: bool
        :param anti_tag: PO tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all PO tags or only some
        :type anti_tags_match_all: bool
        :param event: Event search filter
        :type event: str
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param partial_payment_ref: Partial payment reference search filter
        :type partial_payment_ref: str
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param notes: Notes search filter
        :type notes: str
        :param performer: Performer search filter
        :type performer: str
        :param purchase_id: Purchase Id search filter
        :type purchase_id: List[int]
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param received: Whether the results have received POs
        :type received: bool
        :param venue_ids: Venue id search filter
        :type venue_ids: List[int]
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param credit_card_group_id: Credit card group id search filter
        :type credit_card_group_id: int
        :param credit_card_last_digits: Credit card last digits search filter
        :type credit_card_last_digits: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param in_hand: Whether the results should be in hand
        :type in_hand: bool
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param anti_inventory_tag: Inventory tags to exclude
        :type anti_inventory_tag: List[str]
        :param anti_inventory_tags_match_all: Whether the results should not have all inventory tags or only some
        :type anti_inventory_tags_match_all: bool
        :param no_tags: Whether the results should have inventory tags
        :type no_tags: bool
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param payment_method: Payment method search filter
        :type payment_method: str
        :param min_unit_cost: Minimum unit cost search filter
        :type min_unit_cost: float
        :param max_unit_cost: Maximum unit cost search filter
        :type max_unit_cost: float
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param created_by: Email search filter for PO creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param currency_code: Currency filter
        :type currency_code: str
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param category_id: Performer category search filter
        :type category_id: List[int]
        :param last_purchase_order_note: Last purchase order note
        :type last_purchase_order_note: str
        :param inventory_public_notes: Inventory public notes
        :type inventory_public_notes: str
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_purchased_v2_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            stock_type=stock_type,
            ticket_status=ticket_status,
            event_id=event_id,
            inventory_id=inventory_id,
            performer_id=performer_id,
            vendor_id=vendor_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            event=event,
            venue=venue,
            city=city,
            state=state,
            country=country,
            section=section,
            row=row,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            external_ref=external_ref,
            payment_status=payment_status,
            partial_payment_ref=partial_payment_ref,
            display_name=display_name,
            zone_seating=zone_seating,
            notes=notes,
            performer=performer,
            purchase_id=purchase_id,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            received=received,
            venue_ids=venue_ids,
            consignment=consignment,
            cooperative=cooperative,
            sorted_by=sorted_by,
            credit_card_group_id=credit_card_group_id,
            credit_card_last_digits=credit_card_last_digits,
            event_type=event_type,
            in_hand=in_hand,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            anti_inventory_tag=anti_inventory_tag,
            anti_inventory_tags_match_all=anti_inventory_tags_match_all,
            no_tags=no_tags,
            includes_seat=includes_seat,
            payment_method=payment_method,
            min_unit_cost=min_unit_cost,
            max_unit_cost=max_unit_cost,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            currency_code=currency_code,
            purchase_status=purchase_status,
            category_id=category_id,
            last_purchase_order_note=last_purchase_order_note,
            inventory_public_notes=inventory_public_notes,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchasedInventorySummaryV2]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_search_purchased_v2_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        stock_type,
        ticket_status,
        event_id,
        inventory_id,
        performer_id,
        vendor_id,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        event,
        venue,
        city,
        state,
        country,
        section,
        row,
        purchase_date_from,
        purchase_date_to,
        event_date_from,
        event_date_to,
        external_ref,
        payment_status,
        partial_payment_ref,
        display_name,
        zone_seating,
        notes,
        performer,
        purchase_id,
        in_hand_date_from,
        in_hand_date_to,
        received,
        venue_ids,
        consignment,
        cooperative,
        sorted_by,
        credit_card_group_id,
        credit_card_last_digits,
        event_type,
        in_hand,
        inventory_tag,
        inventory_tags_match_all,
        anti_inventory_tag,
        anti_inventory_tags_match_all,
        no_tags,
        includes_seat,
        payment_method,
        min_unit_cost,
        max_unit_cost,
        min_total_cost,
        max_total_cost,
        created_by,
        created_by_user_id,
        currency_code,
        purchase_status,
        category_id,
        last_purchase_order_note,
        inventory_public_notes,
        event_tag,
        event_tags_match_all,
        anti_event_tag,
        anti_event_tags_match_all,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ticketStatus': 'multi',
            'eventId': 'multi',
            'inventoryId': 'multi',
            'performerId': 'multi',
            'vendorId': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'state': 'multi',
            'country': 'multi',
            'paymentStatus': 'multi',
            'purchaseId': 'multi',
            'venueIds': 'multi',
            'inventoryTag': 'multi',
            'antiInventoryTag': 'multi',
            'purchaseStatus': 'multi',
            'categoryId': 'multi',
            'eventTag': 'multi',
            'antiEventTag': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if stock_type is not None:
            
            _query_params.append(('stockType', stock_type))
            
        if ticket_status is not None:
            
            _query_params.append(('ticketStatus', ticket_status))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if inventory_id is not None:
            
            _query_params.append(('inventoryId', inventory_id))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if purchase_date_from is not None:
            if isinstance(purchase_date_from, datetime):
                _query_params.append(
                    (
                        'purchaseDateFrom',
                        purchase_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateFrom', purchase_date_from))
            
        if purchase_date_to is not None:
            if isinstance(purchase_date_to, datetime):
                _query_params.append(
                    (
                        'purchaseDateTo',
                        purchase_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateTo', purchase_date_to))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if partial_payment_ref is not None:
            
            _query_params.append(('partialPaymentRef', partial_payment_ref))
            
        if display_name is not None:
            
            _query_params.append(('displayName', display_name))
            
        if zone_seating is not None:
            
            _query_params.append(('zoneSeating', zone_seating))
            
        if notes is not None:
            
            _query_params.append(('notes', notes))
            
        if performer is not None:
            
            _query_params.append(('performer', performer))
            
        if purchase_id is not None:
            
            _query_params.append(('purchaseId', purchase_id))
            
        if in_hand_date_from is not None:
            if isinstance(in_hand_date_from, datetime):
                _query_params.append(
                    (
                        'inHandDateFrom',
                        in_hand_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateFrom', in_hand_date_from))
            
        if in_hand_date_to is not None:
            if isinstance(in_hand_date_to, datetime):
                _query_params.append(
                    (
                        'inHandDateTo',
                        in_hand_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateTo', in_hand_date_to))
            
        if received is not None:
            
            _query_params.append(('received', received))
            
        if venue_ids is not None:
            
            _query_params.append(('venueIds', venue_ids))
            
        if consignment is not None:
            
            _query_params.append(('consignment', consignment))
            
        if cooperative is not None:
            
            _query_params.append(('cooperative', cooperative))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        if credit_card_group_id is not None:
            
            _query_params.append(('creditCardGroupId', credit_card_group_id))
            
        if credit_card_last_digits is not None:
            
            _query_params.append(('creditCardLastDigits', credit_card_last_digits))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if in_hand is not None:
            
            _query_params.append(('inHand', in_hand))
            
        if inventory_tag is not None:
            
            _query_params.append(('inventoryTag', inventory_tag))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if anti_inventory_tag is not None:
            
            _query_params.append(('antiInventoryTag', anti_inventory_tag))
            
        if anti_inventory_tags_match_all is not None:
            
            _query_params.append(('antiInventoryTagsMatchAll', anti_inventory_tags_match_all))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if includes_seat is not None:
            
            _query_params.append(('includesSeat', includes_seat))
            
        if payment_method is not None:
            
            _query_params.append(('paymentMethod', payment_method))
            
        if min_unit_cost is not None:
            
            _query_params.append(('minUnitCost', min_unit_cost))
            
        if max_unit_cost is not None:
            
            _query_params.append(('maxUnitCost', max_unit_cost))
            
        if min_total_cost is not None:
            
            _query_params.append(('minTotalCost', min_total_cost))
            
        if max_total_cost is not None:
            
            _query_params.append(('maxTotalCost', max_total_cost))
            
        if created_by is not None:
            
            _query_params.append(('createdBy', created_by))
            
        if created_by_user_id is not None:
            
            _query_params.append(('createdByUserId', created_by_user_id))
            
        if currency_code is not None:
            
            _query_params.append(('currencyCode', currency_code))
            
        if purchase_status is not None:
            
            _query_params.append(('purchaseStatus', purchase_status))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if last_purchase_order_note is not None:
            
            _query_params.append(('lastPurchaseOrderNote', last_purchase_order_note))
            
        if inventory_public_notes is not None:
            
            _query_params.append(('inventoryPublicNotes', inventory_public_notes))
            
        if event_tag is not None:
            
            _query_params.append(('eventTag', event_tag))
            
        if event_tags_match_all is not None:
            
            _query_params.append(('eventTagsMatchAll', event_tags_match_all))
            
        if anti_event_tag is not None:
            
            _query_params.append(('antiEventTag', anti_event_tag))
            
        if anti_event_tags_match_all is not None:
            
            _query_params.append(('antiEventTagsMatchAll', anti_event_tags_match_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/purchased/V2',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_search_sold(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search on")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id to search on")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        invoice_id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id to search on")] = None,
        purchase_ids: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id to search on")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to search on")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type to search on")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        invoice_tag: Annotated[Optional[List[StrictStr]], Field(description="Invoice tags to include")] = None,
        invoice_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all invoice tags or only some")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        purchase_tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        purchase_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all purchase tags or only some")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id to filter")] = None,
        customer_display_name: Annotated[Optional[StrictStr], Field(description="Customer display name filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer to search on")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to search on")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="Invoice external ref filter")] = None,
        purchase_external_ref: Annotated[Optional[StrictStr], Field(description="Purchase external ref filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status to search on")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        pdfs_or_barcodes_attached: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs or Bar Codes attached to all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        internal_notes: Annotated[Optional[StrictStr], Field(description="Internal notes search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="From in hand date filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="To in hand date filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="From fulfillment date filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="To fulfillment date filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results are cooperative")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        invoice_notes: Annotated[Optional[StrictStr], Field(description="Invoice notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        due: Annotated[Optional[StrictBool], Field(description="Whether the inventories are due or not")] = None,
        invoice_created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id of invoice creator")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="Invoice notes user id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        customer_type: Annotated[Optional[StrictStr], Field(description="Whether the results have a customer type of the Invoice")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SoldInventorySummary]:
        """inventory_search_sold

        Gets sold inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param event_id: Event Id to search on
        :type event_id: List[int]
        :param inventory_id: Inventory Id to search on
        :type inventory_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param invoice_id: Invoice Id to search on
        :type invoice_id: List[int]
        :param purchase_ids: Purchase Id to search on
        :type purchase_ids: List[int]
        :param vendor_id: Vendor Id to search on
        :type vendor_id: int
        :param event_type: Event Type to search on
        :type event_type: str
        :param category_id: Category Id filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param invoice_tag: Invoice tags to include
        :type invoice_tag: List[str]
        :param invoice_tags_match_all: Whether the results should have all invoice tags or only some
        :type invoice_tags_match_all: bool
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param purchase_tag: Purchase tags to include
        :type purchase_tag: List[str]
        :param purchase_tags_match_all: Whether the results should have all purchase tags or only some
        :type purchase_tags_match_all: bool
        :param customer_id: Customer Id to filter
        :type customer_id: int
        :param customer_display_name: Customer display name filter
        :type customer_display_name: str
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param performer: Performer to search on
        :type performer: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param event: Event to search on
        :type event: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param venue_id: Venue Id filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param external_ref: Invoice external ref filter
        :type external_ref: List[str]
        :param purchase_external_ref: Purchase external ref filter
        :type purchase_external_ref: str
        :param payment_status: Payment status to search on
        :type payment_status: List[str]
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param pdfs_or_barcodes_attached: Whether the results should have Pdfs or Bar Codes attached to all tickets
        :type pdfs_or_barcodes_attached: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param internal_notes: Internal notes search filter
        :type internal_notes: str
        :param in_hand_date_from: From in hand date filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: To in hand date filter
        :type in_hand_date_to: datetime
        :param fulfillment_date_from: From fulfillment date filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: To fulfillment date filter
        :type fulfillment_date_to: datetime
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param cooperative: Whether the results are cooperative
        :type cooperative: bool
        :param received: Whether the results are received
        :type received: bool
        :param invoice_notes: Invoice notes search filter
        :type invoice_notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param due: Whether the inventories are due or not
        :type due: bool
        :param invoice_created_by: Email search filter for invoice creator
        :type invoice_created_by: str
        :param created_by_user_id: User id of invoice creator
        :type created_by_user_id: int
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param invoice_notes_user_id: Invoice notes user id search filter
        :type invoice_notes_user_id: int
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param customer_type: Whether the results have a customer type of the Invoice
        :type customer_type: str
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_sold_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            event_id=event_id,
            inventory_id=inventory_id,
            exchange_pos_id=exchange_pos_id,
            invoice_id=invoice_id,
            purchase_ids=purchase_ids,
            vendor_id=vendor_id,
            event_type=event_type,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            no_tags=no_tags,
            invoice_tag=invoice_tag,
            invoice_tags_match_all=invoice_tags_match_all,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            purchase_tag=purchase_tag,
            purchase_tags_match_all=purchase_tags_match_all,
            customer_id=customer_id,
            customer_display_name=customer_display_name,
            performer_id=performer_id,
            performer=performer,
            event_keywords=event_keywords,
            event=event,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            venue_id=venue_id,
            venue=venue,
            section=section,
            row=row,
            includes_seat=includes_seat,
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            currency_code=currency_code,
            external_ref=external_ref,
            purchase_external_ref=purchase_external_ref,
            payment_status=payment_status,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            stock_type=stock_type,
            zone_seating=zone_seating,
            pdfs_or_barcodes_attached=pdfs_or_barcodes_attached,
            files_uploaded=files_uploaded,
            barcodes_entered=barcodes_entered,
            electronic_transfer=electronic_transfer,
            internal_notes=internal_notes,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            cooperative=cooperative,
            received=received,
            invoice_notes=invoice_notes,
            public_notes=public_notes,
            state=state,
            country=country,
            due=due,
            invoice_created_by=invoice_created_by,
            created_by_user_id=created_by_user_id,
            day_of_week=day_of_week,
            last_update_from=last_update_from,
            invoice_notes_user_id=invoice_notes_user_id,
            consignment=consignment,
            customer_type=customer_type,
            exclude_parking=exclude_parking,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SoldInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_search_sold_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search on")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id to search on")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        invoice_id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id to search on")] = None,
        purchase_ids: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id to search on")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to search on")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type to search on")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        invoice_tag: Annotated[Optional[List[StrictStr]], Field(description="Invoice tags to include")] = None,
        invoice_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all invoice tags or only some")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        purchase_tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        purchase_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all purchase tags or only some")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id to filter")] = None,
        customer_display_name: Annotated[Optional[StrictStr], Field(description="Customer display name filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer to search on")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to search on")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="Invoice external ref filter")] = None,
        purchase_external_ref: Annotated[Optional[StrictStr], Field(description="Purchase external ref filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status to search on")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        pdfs_or_barcodes_attached: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs or Bar Codes attached to all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        internal_notes: Annotated[Optional[StrictStr], Field(description="Internal notes search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="From in hand date filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="To in hand date filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="From fulfillment date filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="To fulfillment date filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results are cooperative")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        invoice_notes: Annotated[Optional[StrictStr], Field(description="Invoice notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        due: Annotated[Optional[StrictBool], Field(description="Whether the inventories are due or not")] = None,
        invoice_created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id of invoice creator")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="Invoice notes user id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        customer_type: Annotated[Optional[StrictStr], Field(description="Whether the results have a customer type of the Invoice")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SoldInventorySummary]]:
        """inventory_search_sold

        Gets sold inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param event_id: Event Id to search on
        :type event_id: List[int]
        :param inventory_id: Inventory Id to search on
        :type inventory_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param invoice_id: Invoice Id to search on
        :type invoice_id: List[int]
        :param purchase_ids: Purchase Id to search on
        :type purchase_ids: List[int]
        :param vendor_id: Vendor Id to search on
        :type vendor_id: int
        :param event_type: Event Type to search on
        :type event_type: str
        :param category_id: Category Id filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param invoice_tag: Invoice tags to include
        :type invoice_tag: List[str]
        :param invoice_tags_match_all: Whether the results should have all invoice tags or only some
        :type invoice_tags_match_all: bool
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param purchase_tag: Purchase tags to include
        :type purchase_tag: List[str]
        :param purchase_tags_match_all: Whether the results should have all purchase tags or only some
        :type purchase_tags_match_all: bool
        :param customer_id: Customer Id to filter
        :type customer_id: int
        :param customer_display_name: Customer display name filter
        :type customer_display_name: str
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param performer: Performer to search on
        :type performer: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param event: Event to search on
        :type event: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param venue_id: Venue Id filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param external_ref: Invoice external ref filter
        :type external_ref: List[str]
        :param purchase_external_ref: Purchase external ref filter
        :type purchase_external_ref: str
        :param payment_status: Payment status to search on
        :type payment_status: List[str]
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param pdfs_or_barcodes_attached: Whether the results should have Pdfs or Bar Codes attached to all tickets
        :type pdfs_or_barcodes_attached: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param internal_notes: Internal notes search filter
        :type internal_notes: str
        :param in_hand_date_from: From in hand date filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: To in hand date filter
        :type in_hand_date_to: datetime
        :param fulfillment_date_from: From fulfillment date filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: To fulfillment date filter
        :type fulfillment_date_to: datetime
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param cooperative: Whether the results are cooperative
        :type cooperative: bool
        :param received: Whether the results are received
        :type received: bool
        :param invoice_notes: Invoice notes search filter
        :type invoice_notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param due: Whether the inventories are due or not
        :type due: bool
        :param invoice_created_by: Email search filter for invoice creator
        :type invoice_created_by: str
        :param created_by_user_id: User id of invoice creator
        :type created_by_user_id: int
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param invoice_notes_user_id: Invoice notes user id search filter
        :type invoice_notes_user_id: int
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param customer_type: Whether the results have a customer type of the Invoice
        :type customer_type: str
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_sold_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            event_id=event_id,
            inventory_id=inventory_id,
            exchange_pos_id=exchange_pos_id,
            invoice_id=invoice_id,
            purchase_ids=purchase_ids,
            vendor_id=vendor_id,
            event_type=event_type,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            no_tags=no_tags,
            invoice_tag=invoice_tag,
            invoice_tags_match_all=invoice_tags_match_all,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            purchase_tag=purchase_tag,
            purchase_tags_match_all=purchase_tags_match_all,
            customer_id=customer_id,
            customer_display_name=customer_display_name,
            performer_id=performer_id,
            performer=performer,
            event_keywords=event_keywords,
            event=event,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            venue_id=venue_id,
            venue=venue,
            section=section,
            row=row,
            includes_seat=includes_seat,
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            currency_code=currency_code,
            external_ref=external_ref,
            purchase_external_ref=purchase_external_ref,
            payment_status=payment_status,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            stock_type=stock_type,
            zone_seating=zone_seating,
            pdfs_or_barcodes_attached=pdfs_or_barcodes_attached,
            files_uploaded=files_uploaded,
            barcodes_entered=barcodes_entered,
            electronic_transfer=electronic_transfer,
            internal_notes=internal_notes,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            cooperative=cooperative,
            received=received,
            invoice_notes=invoice_notes,
            public_notes=public_notes,
            state=state,
            country=country,
            due=due,
            invoice_created_by=invoice_created_by,
            created_by_user_id=created_by_user_id,
            day_of_week=day_of_week,
            last_update_from=last_update_from,
            invoice_notes_user_id=invoice_notes_user_id,
            consignment=consignment,
            customer_type=customer_type,
            exclude_parking=exclude_parking,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SoldInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_search_sold_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search on")] = None,
        inventory_id: Annotated[Optional[List[StrictInt]], Field(description="Inventory Id to search on")] = None,
        exchange_pos_id: Annotated[Optional[List[StrictInt]], Field(description="Exchange pos Id filter")] = None,
        invoice_id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id to search on")] = None,
        purchase_ids: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id to search on")] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id to search on")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type to search on")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        anti_event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to exclude")] = None,
        anti_event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the event tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        invoice_tag: Annotated[Optional[List[StrictStr]], Field(description="Invoice tags to include")] = None,
        invoice_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all invoice tags or only some")] = None,
        event_tag: Annotated[Optional[List[StrictStr]], Field(description="Event tags to include")] = None,
        event_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all event tags or only some")] = None,
        purchase_tag: Annotated[Optional[List[StrictStr]], Field(description="Purchase tags to include")] = None,
        purchase_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all purchase tags or only some")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id to filter")] = None,
        customer_display_name: Annotated[Optional[StrictStr], Field(description="Customer display name filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer to search on")] = None,
        event_keywords: Annotated[Optional[List[StrictStr]], Field(description="Event keywords filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to search on")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        includes_seat: Annotated[Optional[StrictInt], Field(description="Seat search filter")] = None,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="Invoice external ref filter")] = None,
        purchase_external_ref: Annotated[Optional[StrictStr], Field(description="Purchase external ref filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status to search on")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        pdfs_or_barcodes_attached: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs or Bar Codes attached to all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        electronic_transfer: Annotated[Optional[StrictBool], Field(description="Whether the results should have electronic transfer")] = None,
        internal_notes: Annotated[Optional[StrictStr], Field(description="Internal notes search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="From in hand date filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="To in hand date filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="From fulfillment date filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="To fulfillment date filter")] = None,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results are cooperative")] = None,
        received: Annotated[Optional[StrictBool], Field(description="Whether the results are received")] = None,
        invoice_notes: Annotated[Optional[StrictStr], Field(description="Invoice notes search filter")] = None,
        public_notes: Annotated[Optional[StrictStr], Field(description="Public notes search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        country: Annotated[Optional[List[StrictStr]], Field(description="Country search filter")] = None,
        due: Annotated[Optional[StrictBool], Field(description="Whether the inventories are due or not")] = None,
        invoice_created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id of invoice creator")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Inventory last update date from range filter")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="Invoice notes user id search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        customer_type: Annotated[Optional[StrictStr], Field(description="Whether the results have a customer type of the Invoice")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        min_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total cost search filter")] = None,
        max_total_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total cost search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_search_sold

        Gets sold inventory filtered by query parameters

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param event_id: Event Id to search on
        :type event_id: List[int]
        :param inventory_id: Inventory Id to search on
        :type inventory_id: List[int]
        :param exchange_pos_id: Exchange pos Id filter
        :type exchange_pos_id: List[int]
        :param invoice_id: Invoice Id to search on
        :type invoice_id: List[int]
        :param purchase_ids: Purchase Id to search on
        :type purchase_ids: List[int]
        :param vendor_id: Vendor Id to search on
        :type vendor_id: int
        :param event_type: Event Type to search on
        :type event_type: str
        :param category_id: Category Id filter
        :type category_id: List[int]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param anti_event_tag: Event tags to exclude
        :type anti_event_tag: List[str]
        :param anti_event_tags_match_all: Whether the results should not have all the event tags or only some
        :type anti_event_tags_match_all: bool
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param invoice_tag: Invoice tags to include
        :type invoice_tag: List[str]
        :param invoice_tags_match_all: Whether the results should have all invoice tags or only some
        :type invoice_tags_match_all: bool
        :param event_tag: Event tags to include
        :type event_tag: List[str]
        :param event_tags_match_all: Whether the results should have all event tags or only some
        :type event_tags_match_all: bool
        :param purchase_tag: Purchase tags to include
        :type purchase_tag: List[str]
        :param purchase_tags_match_all: Whether the results should have all purchase tags or only some
        :type purchase_tags_match_all: bool
        :param customer_id: Customer Id to filter
        :type customer_id: int
        :param customer_display_name: Customer display name filter
        :type customer_display_name: str
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param performer: Performer to search on
        :type performer: str
        :param event_keywords: Event keywords filter
        :type event_keywords: List[str]
        :param event: Event to search on
        :type event: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param venue_id: Venue Id filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param includes_seat: Seat search filter
        :type includes_seat: int
        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param external_ref: Invoice external ref filter
        :type external_ref: List[str]
        :param purchase_external_ref: Purchase external ref filter
        :type purchase_external_ref: str
        :param payment_status: Payment status to search on
        :type payment_status: List[str]
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param pdfs_or_barcodes_attached: Whether the results should have Pdfs or Bar Codes attached to all tickets
        :type pdfs_or_barcodes_attached: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param electronic_transfer: Whether the results should have electronic transfer
        :type electronic_transfer: bool
        :param internal_notes: Internal notes search filter
        :type internal_notes: str
        :param in_hand_date_from: From in hand date filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: To in hand date filter
        :type in_hand_date_to: datetime
        :param fulfillment_date_from: From fulfillment date filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: To fulfillment date filter
        :type fulfillment_date_to: datetime
        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param cooperative: Whether the results are cooperative
        :type cooperative: bool
        :param received: Whether the results are received
        :type received: bool
        :param invoice_notes: Invoice notes search filter
        :type invoice_notes: str
        :param public_notes: Public notes search filter
        :type public_notes: str
        :param state: State search filter
        :type state: List[str]
        :param country: Country search filter
        :type country: List[str]
        :param due: Whether the inventories are due or not
        :type due: bool
        :param invoice_created_by: Email search filter for invoice creator
        :type invoice_created_by: str
        :param created_by_user_id: User id of invoice creator
        :type created_by_user_id: int
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param last_update_from: Inventory last update date from range filter
        :type last_update_from: datetime
        :param invoice_notes_user_id: Invoice notes user id search filter
        :type invoice_notes_user_id: int
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param customer_type: Whether the results have a customer type of the Invoice
        :type customer_type: str
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param min_total_cost: Minimum total cost search filter
        :type min_total_cost: float
        :param max_total_cost: Maximum total cost search filter
        :type max_total_cost: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_search_sold_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            sorted_by=sorted_by,
            event_id=event_id,
            inventory_id=inventory_id,
            exchange_pos_id=exchange_pos_id,
            invoice_id=invoice_id,
            purchase_ids=purchase_ids,
            vendor_id=vendor_id,
            event_type=event_type,
            category_id=category_id,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            anti_event_tag=anti_event_tag,
            anti_event_tags_match_all=anti_event_tags_match_all,
            no_tags=no_tags,
            invoice_tag=invoice_tag,
            invoice_tags_match_all=invoice_tags_match_all,
            event_tag=event_tag,
            event_tags_match_all=event_tags_match_all,
            purchase_tag=purchase_tag,
            purchase_tags_match_all=purchase_tags_match_all,
            customer_id=customer_id,
            customer_display_name=customer_display_name,
            performer_id=performer_id,
            performer=performer,
            event_keywords=event_keywords,
            event=event,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            venue_id=venue_id,
            venue=venue,
            section=section,
            row=row,
            includes_seat=includes_seat,
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            currency_code=currency_code,
            external_ref=external_ref,
            purchase_external_ref=purchase_external_ref,
            payment_status=payment_status,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            stock_type=stock_type,
            zone_seating=zone_seating,
            pdfs_or_barcodes_attached=pdfs_or_barcodes_attached,
            files_uploaded=files_uploaded,
            barcodes_entered=barcodes_entered,
            electronic_transfer=electronic_transfer,
            internal_notes=internal_notes,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            cooperative=cooperative,
            received=received,
            invoice_notes=invoice_notes,
            public_notes=public_notes,
            state=state,
            country=country,
            due=due,
            invoice_created_by=invoice_created_by,
            created_by_user_id=created_by_user_id,
            day_of_week=day_of_week,
            last_update_from=last_update_from,
            invoice_notes_user_id=invoice_notes_user_id,
            consignment=consignment,
            customer_type=customer_type,
            exclude_parking=exclude_parking,
            min_total_cost=min_total_cost,
            max_total_cost=max_total_cost,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SoldInventorySummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_search_sold_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        sorted_by,
        event_id,
        inventory_id,
        exchange_pos_id,
        invoice_id,
        purchase_ids,
        vendor_id,
        event_type,
        category_id,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        anti_event_tag,
        anti_event_tags_match_all,
        no_tags,
        invoice_tag,
        invoice_tags_match_all,
        event_tag,
        event_tags_match_all,
        purchase_tag,
        purchase_tags_match_all,
        customer_id,
        customer_display_name,
        performer_id,
        performer,
        event_keywords,
        event,
        event_date_from,
        event_date_to,
        venue_id,
        venue,
        section,
        row,
        includes_seat,
        invoice_date_from,
        invoice_date_to,
        currency_code,
        external_ref,
        purchase_external_ref,
        payment_status,
        invoice_status,
        fulfillment_status,
        stock_type,
        zone_seating,
        pdfs_or_barcodes_attached,
        files_uploaded,
        barcodes_entered,
        electronic_transfer,
        internal_notes,
        in_hand_date_from,
        in_hand_date_to,
        fulfillment_date_from,
        fulfillment_date_to,
        purchase_date_from,
        purchase_date_to,
        cooperative,
        received,
        invoice_notes,
        public_notes,
        state,
        country,
        due,
        invoice_created_by,
        created_by_user_id,
        day_of_week,
        last_update_from,
        invoice_notes_user_id,
        consignment,
        customer_type,
        exclude_parking,
        min_total_cost,
        max_total_cost,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'eventId': 'multi',
            'inventoryId': 'multi',
            'exchangePosId': 'multi',
            'invoiceId': 'multi',
            'purchaseIds': 'multi',
            'categoryId': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'antiEventTag': 'multi',
            'invoiceTag': 'multi',
            'eventTag': 'multi',
            'purchaseTag': 'multi',
            'eventKeywords': 'multi',
            'externalRef': 'multi',
            'paymentStatus': 'multi',
            'invoiceStatus': 'multi',
            'state': 'multi',
            'country': 'multi',
            'dayOfWeek': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if inventory_id is not None:
            
            _query_params.append(('inventoryId', inventory_id))
            
        if exchange_pos_id is not None:
            
            _query_params.append(('exchangePosId', exchange_pos_id))
            
        if invoice_id is not None:
            
            _query_params.append(('invoiceId', invoice_id))
            
        if purchase_ids is not None:
            
            _query_params.append(('purchaseIds', purchase_ids))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if anti_event_tag is not None:
            
            _query_params.append(('antiEventTag', anti_event_tag))
            
        if anti_event_tags_match_all is not None:
            
            _query_params.append(('antiEventTagsMatchAll', anti_event_tags_match_all))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if invoice_tag is not None:
            
            _query_params.append(('invoiceTag', invoice_tag))
            
        if invoice_tags_match_all is not None:
            
            _query_params.append(('invoiceTagsMatchAll', invoice_tags_match_all))
            
        if event_tag is not None:
            
            _query_params.append(('eventTag', event_tag))
            
        if event_tags_match_all is not None:
            
            _query_params.append(('eventTagsMatchAll', event_tags_match_all))
            
        if purchase_tag is not None:
            
            _query_params.append(('purchaseTag', purchase_tag))
            
        if purchase_tags_match_all is not None:
            
            _query_params.append(('purchaseTagsMatchAll', purchase_tags_match_all))
            
        if customer_id is not None:
            
            _query_params.append(('customerId', customer_id))
            
        if customer_display_name is not None:
            
            _query_params.append(('customerDisplayName', customer_display_name))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if performer is not None:
            
            _query_params.append(('performer', performer))
            
        if event_keywords is not None:
            
            _query_params.append(('eventKeywords', event_keywords))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if includes_seat is not None:
            
            _query_params.append(('includesSeat', includes_seat))
            
        if invoice_date_from is not None:
            if isinstance(invoice_date_from, datetime):
                _query_params.append(
                    (
                        'invoiceDateFrom',
                        invoice_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('invoiceDateFrom', invoice_date_from))
            
        if invoice_date_to is not None:
            if isinstance(invoice_date_to, datetime):
                _query_params.append(
                    (
                        'invoiceDateTo',
                        invoice_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('invoiceDateTo', invoice_date_to))
            
        if currency_code is not None:
            
            _query_params.append(('currencyCode', currency_code))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if purchase_external_ref is not None:
            
            _query_params.append(('purchaseExternalRef', purchase_external_ref))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if invoice_status is not None:
            
            _query_params.append(('invoiceStatus', invoice_status))
            
        if fulfillment_status is not None:
            
            _query_params.append(('fulfillmentStatus', fulfillment_status))
            
        if stock_type is not None:
            
            _query_params.append(('stockType', stock_type))
            
        if zone_seating is not None:
            
            _query_params.append(('zoneSeating', zone_seating))
            
        if pdfs_or_barcodes_attached is not None:
            
            _query_params.append(('pdfsOrBarcodesAttached', pdfs_or_barcodes_attached))
            
        if files_uploaded is not None:
            
            _query_params.append(('filesUploaded', files_uploaded))
            
        if barcodes_entered is not None:
            
            _query_params.append(('barcodesEntered', barcodes_entered))
            
        if electronic_transfer is not None:
            
            _query_params.append(('electronicTransfer', electronic_transfer))
            
        if internal_notes is not None:
            
            _query_params.append(('internalNotes', internal_notes))
            
        if in_hand_date_from is not None:
            if isinstance(in_hand_date_from, datetime):
                _query_params.append(
                    (
                        'inHandDateFrom',
                        in_hand_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateFrom', in_hand_date_from))
            
        if in_hand_date_to is not None:
            if isinstance(in_hand_date_to, datetime):
                _query_params.append(
                    (
                        'inHandDateTo',
                        in_hand_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateTo', in_hand_date_to))
            
        if fulfillment_date_from is not None:
            if isinstance(fulfillment_date_from, datetime):
                _query_params.append(
                    (
                        'fulfillmentDateFrom',
                        fulfillment_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fulfillmentDateFrom', fulfillment_date_from))
            
        if fulfillment_date_to is not None:
            if isinstance(fulfillment_date_to, datetime):
                _query_params.append(
                    (
                        'fulfillmentDateTo',
                        fulfillment_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fulfillmentDateTo', fulfillment_date_to))
            
        if purchase_date_from is not None:
            if isinstance(purchase_date_from, datetime):
                _query_params.append(
                    (
                        'purchaseDateFrom',
                        purchase_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateFrom', purchase_date_from))
            
        if purchase_date_to is not None:
            if isinstance(purchase_date_to, datetime):
                _query_params.append(
                    (
                        'purchaseDateTo',
                        purchase_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateTo', purchase_date_to))
            
        if cooperative is not None:
            
            _query_params.append(('cooperative', cooperative))
            
        if received is not None:
            
            _query_params.append(('received', received))
            
        if invoice_notes is not None:
            
            _query_params.append(('invoiceNotes', invoice_notes))
            
        if public_notes is not None:
            
            _query_params.append(('publicNotes', public_notes))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if due is not None:
            
            _query_params.append(('due', due))
            
        if invoice_created_by is not None:
            
            _query_params.append(('invoiceCreatedBy', invoice_created_by))
            
        if created_by_user_id is not None:
            
            _query_params.append(('createdByUserId', created_by_user_id))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if last_update_from is not None:
            if isinstance(last_update_from, datetime):
                _query_params.append(
                    (
                        'lastUpdateFrom',
                        last_update_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateFrom', last_update_from))
            
        if invoice_notes_user_id is not None:
            
            _query_params.append(('invoiceNotesUserId', invoice_notes_user_id))
            
        if consignment is not None:
            
            _query_params.append(('consignment', consignment))
            
        if customer_type is not None:
            
            _query_params.append(('customerType', customer_type))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if min_total_cost is not None:
            
            _query_params.append(('minTotalCost', min_total_cost))
            
        if max_total_cost is not None:
            
            _query_params.append(('maxTotalCost', max_total_cost))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/inventory/sold',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_sold_bulk_swap_event(
        self,
        bulk_sold_swap_event_request: Annotated[BulkSoldSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_sold_bulk_swap_event

        Sold bulk swap event

        :param bulk_sold_swap_event_request: Payload (required)
        :type bulk_sold_swap_event_request: BulkSoldSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sold_bulk_swap_event_serialize(
            bulk_sold_swap_event_request=bulk_sold_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_sold_bulk_swap_event_with_http_info(
        self,
        bulk_sold_swap_event_request: Annotated[BulkSoldSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_sold_bulk_swap_event

        Sold bulk swap event

        :param bulk_sold_swap_event_request: Payload (required)
        :type bulk_sold_swap_event_request: BulkSoldSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sold_bulk_swap_event_serialize(
            bulk_sold_swap_event_request=bulk_sold_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_sold_bulk_swap_event_without_preload_content(
        self,
        bulk_sold_swap_event_request: Annotated[BulkSoldSwapEventRequest, Field(description="Payload")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_sold_bulk_swap_event

        Sold bulk swap event

        :param bulk_sold_swap_event_request: Payload (required)
        :type bulk_sold_swap_event_request: BulkSoldSwapEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sold_bulk_swap_event_serialize(
            bulk_sold_swap_event_request=bulk_sold_swap_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_sold_bulk_swap_event_serialize(
        self,
        bulk_sold_swap_event_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_sold_swap_event_request is not None:
            _body_params = bulk_sold_swap_event_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/sold/bulk-swap-event',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_split(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        body: Annotated[StrictInt, Field(description="The ticket quantity of the first group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """inventory_split

        Splits inventory into 2 new inventory groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param body: The ticket quantity of the first group (required)
        :type body: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_serialize(
            inventory_id=inventory_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_split_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        body: Annotated[StrictInt, Field(description="The ticket quantity of the first group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """inventory_split

        Splits inventory into 2 new inventory groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param body: The ticket quantity of the first group (required)
        :type body: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_serialize(
            inventory_id=inventory_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_split_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        body: Annotated[StrictInt, Field(description="The ticket quantity of the first group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_split

        Splits inventory into 2 new inventory groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param body: The ticket quantity of the first group (required)
        :type body: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_serialize(
            inventory_id=inventory_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_split_serialize(
        self,
        inventory_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/{inventory-id}/split',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_split_to_consecutive(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[float]:
        """inventory_split_to_consecutive

        Splits inventory into 2 new inventory consecutive groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_consecutive_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_split_to_consecutive_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[float]]:
        """inventory_split_to_consecutive

        Splits inventory into 2 new inventory consecutive groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_consecutive_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_split_to_consecutive_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The ID of the inventory to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_split_to_consecutive

        Splits inventory into 2 new inventory consecutive groups

        :param inventory_id: The ID of the inventory to update (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_consecutive_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[float]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_split_to_consecutive_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/{inventory-id}/split-to-consecutive',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_split_to_originals(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to split")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Inventory]:
        """inventory_split_to_originals

        Splits and merges inventories to leave them as they were when purchased

        :param inventory_id: The Id of the inventory to split (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_originals_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_split_to_originals_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to split")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Inventory]]:
        """inventory_split_to_originals

        Splits and merges inventories to leave them as they were when purchased

        :param inventory_id: The Id of the inventory to split (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_originals_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_split_to_originals_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to split")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_split_to_originals

        Splits and merges inventories to leave them as they were when purchased

        :param inventory_id: The Id of the inventory to split (required)
        :type inventory_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_split_to_originals_serialize(
            inventory_id=inventory_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_split_to_originals_serialize(
        self,
        inventory_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/{inventory-id}/actions/split-to-originals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_sync(
        self,
        sync_inventory_request: Annotated[SyncInventoryRequest, Field(description="The inventory Ids to sync")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_sync

        Sync Inventory with integrated services

        :param sync_inventory_request: The inventory Ids to sync (required)
        :type sync_inventory_request: SyncInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sync_serialize(
            sync_inventory_request=sync_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_sync_with_http_info(
        self,
        sync_inventory_request: Annotated[SyncInventoryRequest, Field(description="The inventory Ids to sync")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_sync

        Sync Inventory with integrated services

        :param sync_inventory_request: The inventory Ids to sync (required)
        :type sync_inventory_request: SyncInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sync_serialize(
            sync_inventory_request=sync_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_sync_without_preload_content(
        self,
        sync_inventory_request: Annotated[SyncInventoryRequest, Field(description="The inventory Ids to sync")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_sync

        Sync Inventory with integrated services

        :param sync_inventory_request: The inventory Ids to sync (required)
        :type sync_inventory_request: SyncInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_sync_serialize(
            sync_inventory_request=sync_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_sync_serialize(
        self,
        sync_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if sync_inventory_request is not None:
            _body_params = sync_inventory_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/sync',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_tag(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_tag

        Inserts a new tags for an inventory. Duplicates are ignored

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_tag_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_tag_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_tag

        Inserts a new tags for an inventory. Duplicates are ignored

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_tag_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_tag_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_tag

        Inserts a new tags for an inventory. Duplicates are ignored

        :param inventory_id: The Id of the inventory (required)
        :type inventory_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_tag_serialize(
            inventory_id=inventory_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_tag_serialize(
        self,
        inventory_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/{inventory-id}/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_update(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to update")],
        inventory: Annotated[Inventory, Field(description="Inventory update")],
        change_seat_numbers: Annotated[Optional[StrictBool], Field(description="Whether is allow to change seat number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_update

        Update Inventory

        :param inventory_id: The Id of the inventory to update (required)
        :type inventory_id: int
        :param inventory: Inventory update (required)
        :type inventory: Inventory
        :param change_seat_numbers: Whether is allow to change seat number
        :type change_seat_numbers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_serialize(
            inventory_id=inventory_id,
            inventory=inventory,
            change_seat_numbers=change_seat_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_update_with_http_info(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to update")],
        inventory: Annotated[Inventory, Field(description="Inventory update")],
        change_seat_numbers: Annotated[Optional[StrictBool], Field(description="Whether is allow to change seat number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_update

        Update Inventory

        :param inventory_id: The Id of the inventory to update (required)
        :type inventory_id: int
        :param inventory: Inventory update (required)
        :type inventory: Inventory
        :param change_seat_numbers: Whether is allow to change seat number
        :type change_seat_numbers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_serialize(
            inventory_id=inventory_id,
            inventory=inventory,
            change_seat_numbers=change_seat_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_update_without_preload_content(
        self,
        inventory_id: Annotated[StrictInt, Field(description="The Id of the inventory to update")],
        inventory: Annotated[Inventory, Field(description="Inventory update")],
        change_seat_numbers: Annotated[Optional[StrictBool], Field(description="Whether is allow to change seat number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_update

        Update Inventory

        :param inventory_id: The Id of the inventory to update (required)
        :type inventory_id: int
        :param inventory: Inventory update (required)
        :type inventory: Inventory
        :param change_seat_numbers: Whether is allow to change seat number
        :type change_seat_numbers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_serialize(
            inventory_id=inventory_id,
            inventory=inventory,
            change_seat_numbers=change_seat_numbers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_update_serialize(
        self,
        inventory_id,
        inventory,
        change_seat_numbers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if inventory_id is not None:
            _path_params['inventory-id'] = inventory_id
        # process the query parameters
        if change_seat_numbers is not None:
            
            _query_params.append(('changeSeatNumbers', change_seat_numbers))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inventory is not None:
            _body_params = inventory



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/inventory/{inventory-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def inventory_update_purchase_inventory(
        self,
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """inventory_update_purchase_inventory

        Updates section and row for an inventory

        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_purchase_inventory_serialize(
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def inventory_update_purchase_inventory_with_http_info(
        self,
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """inventory_update_purchase_inventory

        Updates section and row for an inventory

        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_purchase_inventory_serialize(
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def inventory_update_purchase_inventory_without_preload_content(
        self,
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """inventory_update_purchase_inventory

        Updates section and row for an inventory

        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._inventory_update_purchase_inventory_serialize(
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _inventory_update_purchase_inventory_serialize(
        self,
        update_purchase_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_purchase_inventory_request is not None:
            _body_params = update_purchase_inventory_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/inventory/actions/edit-section-row',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


