# coding: utf-8

"""
    SkyBox API

    The SkyBox APIs allow our users to create, update, delete, and export information within the SkyBox platform. These APIs allow SkyBox to be extensible, giving you the flexibility to grow, develop, and integrate third-party tooling to help scale out your business. To begin using the SkyBox APIs, you will need to generate two unique tokens: an Application_Token and an API Token.  To request a unique Application_Token, click here (<a href='https://skybox.vividseats.com/application-sign-up'>https://skybox.vividseats.com/application-sign-up</a>) and refer to this <a href='https://skybox.zendesk.com/hc/en-us/articles/6769735238043-Getting-Started-with-Skybox-APIs'>Zendesk Article</a> for detailed instructions on getting started with SkyBox APIs.  To generate an API Token when logged in to SkyBox, click on the drop-down under 'Logged In As:', select 'External Accounts', and then select 'API Invitation +'. A modal will appear and you will be prompted to enter the email address to which you want the token sent as well as to provide a brief description of the account.  Once you have both your Application_Token and API Token, there are two ways in which you can make requests: through the UI and through a third party. See below for detailed steps for each process.  Requests through the UI:  To begin, enter your Account ID in the X-Account field. Once complete, select _Authorize_. Next, enter your API Token in the X-Api-Token field. If you do not currently have an API Token, please follow the steps above to request one. Once complete, select _Authorize_. Last, enter your Application_Token in the X-Application-Token field. If you do not have an Application_Token, a sample is provided or you can follow the link above to request one. Once complete, select _Authorize_.  Requests through a third party (i.e. Postman):  The same information is required as it is through the UI, but it will be passed in through headers. It should look something like this:  X-Account: Account ID goes here!  X-Api-Token: API Token goes here!  X-Application-Token: Application_Token goes here!  Once these three items are successfully passed in as headers, you will be able to make sample requests.  <h2><a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>API Rate Limits</a> </h2>  A rate limit consists of two variables: an interval and a limit. An interval is a period of time, measured in seconds. A limit is the number of calls that can be made to an endpoint in an interval.  For example, SkyBox’s ‘GET /reports/‘ endpoint has an interval of 1 second and a limit of 1 call per interval. This means that this endpoint has a rate limit of 1 call/second.  Each endpoint, and its respective rate limit, is displayed in this <a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>Support Article</a>. If the endpoint is not listed, its rate limit is the default, indicated by the ‘*’ at the bottom of the table. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from skybox_openapi_client.models.category import Category
from skybox_openapi_client.models.event_position import EventPosition
from skybox_openapi_client.models.performer_position import PerformerPosition

from skybox_openapi_client.api_client import ApiClient, RequestSerialized
from skybox_openapi_client.api_response import ApiResponse
from skybox_openapi_client.rest import RESTResponseType


class EventPositionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def event_positions_event_positions_totals(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[EventPosition]:
        """event_positions_event_positions_totals

        Retrieves event positions totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_totals_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def event_positions_event_positions_totals_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[EventPosition]]:
        """event_positions_event_positions_totals

        Retrieves event positions totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_totals_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def event_positions_event_positions_totals_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """event_positions_event_positions_totals

        Retrieves event positions totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_totals_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _event_positions_event_positions_totals_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        section,
        row,
        listed,
        event_id,
        event,
        keywords,
        event_date_from,
        event_date_to,
        event_time_from,
        event_time_to,
        day_of_week,
        event_type,
        category_id,
        category,
        venue_id,
        venue,
        city,
        state,
        performer_id,
        tags_match_all,
        anti_tags_match_all,
        inventory_tags_match_all,
        no_tags,
        exclude_only_zone_inventory,
        exclude_parking,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'eventId': 'multi',
            'keywords': 'multi',
            'dayOfWeek': 'multi',
            'state': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if listed is not None:
            
            _query_params.append(('listed', listed))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if event_time_from is not None:
            
            _query_params.append(('eventTimeFrom', event_time_from))
            
        if event_time_to is not None:
            
            _query_params.append(('eventTimeTo', event_time_to))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if exclude_only_zone_inventory is not None:
            
            _query_params.append(('excludeOnlyZoneInventory', exclude_only_zone_inventory))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/event_positions/totals',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def event_positions_event_positions_values(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[EventPosition]:
        """event_positions_event_positions_values

        Retrieves event positions without totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_values_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def event_positions_event_positions_values_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[EventPosition]]:
        """event_positions_event_positions_values

        Retrieves event positions without totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_values_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def event_positions_event_positions_values_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """event_positions_event_positions_values

        Retrieves event positions without totals

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_event_positions_values_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _event_positions_event_positions_values_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        section,
        row,
        listed,
        event_id,
        event,
        keywords,
        event_date_from,
        event_date_to,
        event_time_from,
        event_time_to,
        day_of_week,
        event_type,
        category_id,
        category,
        venue_id,
        venue,
        city,
        state,
        performer_id,
        tags_match_all,
        anti_tags_match_all,
        inventory_tags_match_all,
        no_tags,
        exclude_only_zone_inventory,
        exclude_parking,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'eventId': 'multi',
            'keywords': 'multi',
            'dayOfWeek': 'multi',
            'state': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if listed is not None:
            
            _query_params.append(('listed', listed))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if event_time_from is not None:
            
            _query_params.append(('eventTimeFrom', event_time_from))
            
        if event_time_to is not None:
            
            _query_params.append(('eventTimeTo', event_time_to))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if exclude_only_zone_inventory is not None:
            
            _query_params.append(('excludeOnlyZoneInventory', exclude_only_zone_inventory))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/event_positions/values',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def event_positions_get_categories(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Category]:
        """event_positions_get_categories

        Retrieves event positions grouped by category

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Category]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def event_positions_get_categories_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Category]]:
        """event_positions_get_categories

        Retrieves event positions grouped by category

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Category]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def event_positions_get_categories_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """event_positions_get_categories

        Retrieves event positions grouped by category

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_categories_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Category]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _event_positions_get_categories_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/event_positions/categories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def event_positions_get_performers(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer name search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PerformerPosition]:
        """event_positions_get_performers

        Retrieves event positions grouped by performer

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param performer: Performer name search filter
        :type performer: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_performers_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            performer_id=performer_id,
            performer=performer,
            event_type=event_type,
            category_id=category_id,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            day_of_week=day_of_week,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PerformerPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def event_positions_get_performers_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer name search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PerformerPosition]]:
        """event_positions_get_performers

        Retrieves event positions grouped by performer

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param performer: Performer name search filter
        :type performer: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_performers_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            performer_id=performer_id,
            performer=performer,
            event_type=event_type,
            category_id=category_id,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            day_of_week=day_of_week,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PerformerPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def event_positions_get_performers_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        performer_id: Annotated[Optional[List[StrictInt]], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer name search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """event_positions_get_performers

        Retrieves event positions grouped by performer

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param performer_id: Performer Id search filter
        :type performer_id: List[int]
        :param performer: Performer name search filter
        :type performer: str
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_get_performers_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            performer_id=performer_id,
            performer=performer,
            event_type=event_type,
            category_id=category_id,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            day_of_week=day_of_week,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PerformerPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _event_positions_get_performers_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        performer_id,
        performer,
        event_type,
        category_id,
        event_date_from,
        event_date_to,
        day_of_week,
        exclude_parking,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'performerId': 'multi',
            'dayOfWeek': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if performer is not None:
            
            _query_params.append(('performer', performer))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/event_positions/performers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def event_positions_index(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[EventPosition]:
        """event_positions_index

        Retrieves event positions

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_index_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def event_positions_index_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[EventPosition]]:
        """event_positions_index

        Retrieves event positions

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_index_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def event_positions_index_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        section: Annotated[Optional[StrictStr], Field(description="Section search filter")] = None,
        row: Annotated[Optional[StrictStr], Field(description="Row search filter")] = None,
        listed: Annotated[Optional[StrictBool], Field(description="Whether inventories are listed")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id to search by")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event search term")] = None,
        keywords: Annotated[Optional[List[StrictStr]], Field(description="Search Keywords")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Minimum event date in yyyy-MM-dd format")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Maximum event date in yyyy-MM-dd format")] = None,
        event_time_from: Annotated[Optional[StrictStr], Field(description="Only search events starting not earlier than")] = None,
        event_time_to: Annotated[Optional[StrictStr], Field(description="Only search events starting not later than")] = None,
        day_of_week: Annotated[Optional[List[StrictInt]], Field(description="Day of the week of events that occur on that day of the week")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue Id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        city: Annotated[Optional[StrictStr], Field(description="City search filter")] = None,
        state: Annotated[Optional[List[StrictStr]], Field(description="State search filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id filter")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Inventory tags to exclude")] = None,
        exclude_only_zone_inventory: Annotated[Optional[StrictBool], Field(description="Whether to exclude events with all zoned inventories")] = None,
        exclude_parking: Annotated[Optional[StrictBool], Field(description="Whether parking events are excluded")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """event_positions_index

        Retrieves event positions

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param section: Section search filter
        :type section: str
        :param row: Row search filter
        :type row: str
        :param listed: Whether inventories are listed
        :type listed: bool
        :param event_id: Event Id to search by
        :type event_id: List[int]
        :param event: Event search term
        :type event: str
        :param keywords: Search Keywords
        :type keywords: List[str]
        :param event_date_from: Minimum event date in yyyy-MM-dd format
        :type event_date_from: datetime
        :param event_date_to: Maximum event date in yyyy-MM-dd format
        :type event_date_to: datetime
        :param event_time_from: Only search events starting not earlier than
        :type event_time_from: str
        :param event_time_to: Only search events starting not later than
        :type event_time_to: str
        :param day_of_week: Day of the week of events that occur on that day of the week
        :type day_of_week: List[int]
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param category: Category search filter
        :type category: str
        :param venue_id: Venue Id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param city: City search filter
        :type city: str
        :param state: State search filter
        :type state: List[str]
        :param performer_id: Performer Id filter
        :type performer_id: int
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param no_tags: Inventory tags to exclude
        :type no_tags: bool
        :param exclude_only_zone_inventory: Whether to exclude events with all zoned inventories
        :type exclude_only_zone_inventory: bool
        :param exclude_parking: Whether parking events are excluded
        :type exclude_parking: bool
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._event_positions_index_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            section=section,
            row=row,
            listed=listed,
            event_id=event_id,
            event=event,
            keywords=keywords,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            event_time_from=event_time_from,
            event_time_to=event_time_to,
            day_of_week=day_of_week,
            event_type=event_type,
            category_id=category_id,
            category=category,
            venue_id=venue_id,
            venue=venue,
            city=city,
            state=state,
            performer_id=performer_id,
            tags_match_all=tags_match_all,
            anti_tags_match_all=anti_tags_match_all,
            inventory_tags_match_all=inventory_tags_match_all,
            no_tags=no_tags,
            exclude_only_zone_inventory=exclude_only_zone_inventory,
            exclude_parking=exclude_parking,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[EventPosition]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _event_positions_index_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        section,
        row,
        listed,
        event_id,
        event,
        keywords,
        event_date_from,
        event_date_to,
        event_time_from,
        event_time_to,
        day_of_week,
        event_type,
        category_id,
        category,
        venue_id,
        venue,
        city,
        state,
        performer_id,
        tags_match_all,
        anti_tags_match_all,
        inventory_tags_match_all,
        no_tags,
        exclude_only_zone_inventory,
        exclude_parking,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'eventId': 'multi',
            'keywords': 'multi',
            'dayOfWeek': 'multi',
            'state': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if section is not None:
            
            _query_params.append(('section', section))
            
        if row is not None:
            
            _query_params.append(('row', row))
            
        if listed is not None:
            
            _query_params.append(('listed', listed))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if keywords is not None:
            
            _query_params.append(('keywords', keywords))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if event_time_from is not None:
            
            _query_params.append(('eventTimeFrom', event_time_from))
            
        if event_time_to is not None:
            
            _query_params.append(('eventTimeTo', event_time_to))
            
        if day_of_week is not None:
            
            _query_params.append(('dayOfWeek', day_of_week))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if exclude_only_zone_inventory is not None:
            
            _query_params.append(('excludeOnlyZoneInventory', exclude_only_zone_inventory))
            
        if exclude_parking is not None:
            
            _query_params.append(('excludeParking', exclude_parking))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/event_positions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


