# coding: utf-8

"""
    SkyBox API

    The SkyBox APIs allow our users to create, update, delete, and export information within the SkyBox platform. These APIs allow SkyBox to be extensible, giving you the flexibility to grow, develop, and integrate third-party tooling to help scale out your business. To begin using the SkyBox APIs, you will need to generate two unique tokens: an Application_Token and an API Token.  To request a unique Application_Token, click here (<a href='https://skybox.vividseats.com/application-sign-up'>https://skybox.vividseats.com/application-sign-up</a>) and refer to this <a href='https://skybox.zendesk.com/hc/en-us/articles/6769735238043-Getting-Started-with-Skybox-APIs'>Zendesk Article</a> for detailed instructions on getting started with SkyBox APIs.  To generate an API Token when logged in to SkyBox, click on the drop-down under 'Logged In As:', select 'External Accounts', and then select 'API Invitation +'. A modal will appear and you will be prompted to enter the email address to which you want the token sent as well as to provide a brief description of the account.  Once you have both your Application_Token and API Token, there are two ways in which you can make requests: through the UI and through a third party. See below for detailed steps for each process.  Requests through the UI:  To begin, enter your Account ID in the X-Account field. Once complete, select _Authorize_. Next, enter your API Token in the X-Api-Token field. If you do not currently have an API Token, please follow the steps above to request one. Once complete, select _Authorize_. Last, enter your Application_Token in the X-Application-Token field. If you do not have an Application_Token, a sample is provided or you can follow the link above to request one. Once complete, select _Authorize_.  Requests through a third party (i.e. Postman):  The same information is required as it is through the UI, but it will be passed in through headers. It should look something like this:  X-Account: Account ID goes here!  X-Api-Token: API Token goes here!  X-Application-Token: Application_Token goes here!  Once these three items are successfully passed in as headers, you will be able to make sample requests.  <h2><a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>API Rate Limits</a> </h2>  A rate limit consists of two variables: an interval and a limit. An interval is a period of time, measured in seconds. A limit is the number of calls that can be made to an endpoint in an interval.  For example, SkyBox’s ‘GET /reports/‘ endpoint has an interval of 1 second and a limit of 1 call per interval. This means that this endpoint has a rate limit of 1 call/second.  Each endpoint, and its respective rate limit, is displayed in this <a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>Support Article</a>. If the endpoint is not listed, its rate limit is the default, indicated by the ‘*’ at the bottom of the table. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from skybox_openapi_client.models.bulk_purchase_update import BulkPurchaseUpdate
from skybox_openapi_client.models.currency_update_bulk_action import CurrencyUpdateBulkAction
from skybox_openapi_client.models.inventory import Inventory
from skybox_openapi_client.models.line import Line
from skybox_openapi_client.models.purchase import Purchase
from skybox_openapi_client.models.purchase_line_replace_action import PurchaseLineReplaceAction
from skybox_openapi_client.models.purchase_note import PurchaseNote
from skybox_openapi_client.models.purchase_summary import PurchaseSummary
from skybox_openapi_client.models.tag_request import TagRequest
from skybox_openapi_client.models.ticket import Ticket
from skybox_openapi_client.models.update_purchase_inventory_request import UpdatePurchaseInventoryRequest

from skybox_openapi_client.api_client import ApiClient, RequestSerialized
from skybox_openapi_client.api_response import ApiResponse
from skybox_openapi_client.rest import RESTResponseType


class PurchasesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def purchases_add_purchase_note(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase_note: Annotated[PurchaseNote, Field(description="Purchase note object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PurchaseNote:
        """purchases_add_purchase_note

        Adds a purchase note

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase_note: Purchase note object (required)
        :type purchase_note: PurchaseNote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_add_purchase_note_serialize(
            purchase_id=purchase_id,
            purchase_note=purchase_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_add_purchase_note_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase_note: Annotated[PurchaseNote, Field(description="Purchase note object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PurchaseNote]:
        """purchases_add_purchase_note

        Adds a purchase note

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase_note: Purchase note object (required)
        :type purchase_note: PurchaseNote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_add_purchase_note_serialize(
            purchase_id=purchase_id,
            purchase_note=purchase_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_add_purchase_note_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase_note: Annotated[PurchaseNote, Field(description="Purchase note object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_add_purchase_note

        Adds a purchase note

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase_note: Purchase note object (required)
        :type purchase_note: PurchaseNote
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_add_purchase_note_serialize(
            purchase_id=purchase_id,
            purchase_note=purchase_note,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_add_purchase_note_serialize(
        self,
        purchase_id,
        purchase_note,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if purchase_note is not None:
            _body_params = purchase_note


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/notes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_bulk_cancel_lines(
        self,
        request_body: Annotated[List[StrictInt], Field(description="The list of purchase ids to cancel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_bulk_cancel_lines

        Cancels a list of purchase lines

        :param request_body: The list of purchase ids to cancel (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_cancel_lines_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_bulk_cancel_lines_with_http_info(
        self,
        request_body: Annotated[List[StrictInt], Field(description="The list of purchase ids to cancel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_bulk_cancel_lines

        Cancels a list of purchase lines

        :param request_body: The list of purchase ids to cancel (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_cancel_lines_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_bulk_cancel_lines_without_preload_content(
        self,
        request_body: Annotated[List[StrictInt], Field(description="The list of purchase ids to cancel")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_bulk_cancel_lines

        Cancels a list of purchase lines

        :param request_body: The list of purchase ids to cancel (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_cancel_lines_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_bulk_cancel_lines_serialize(
        self,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/actions/cancel-lines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_bulk_remove_tags(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Purchase Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_bulk_remove_tags

        Deletes all tags from purchases with given ids

        :param request_body: Purchase Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_bulk_remove_tags_with_http_info(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Purchase Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_bulk_remove_tags

        Deletes all tags from purchases with given ids

        :param request_body: Purchase Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_bulk_remove_tags_without_preload_content(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Purchase Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_bulk_remove_tags

        Deletes all tags from purchases with given ids

        :param request_body: Purchase Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_bulk_remove_tags_serialize(
        self,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/tags/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_cancel_purchase_line(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_cancel_purchase_line

        Cancels a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_cancel_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_cancel_purchase_line_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_cancel_purchase_line

        Cancels a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_cancel_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_cancel_purchase_line_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_cancel_purchase_line

        Cancels a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_cancel_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_cancel_purchase_line_serialize(
        self,
        purchase_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/purchases/{purchase-id}/lines/{line-id}/cancel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_delete(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_delete

        Deletes tags for a purchase

        :param purchase_id: The purchase Id (required)
        :type purchase_id: int
        :param tag_request: Tags to be removed from the purchase (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_delete_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_delete_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_delete

        Deletes tags for a purchase

        :param purchase_id: The purchase Id (required)
        :type purchase_id: int
        :param tag_request: Tags to be removed from the purchase (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_delete_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_delete_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_delete

        Deletes tags for a purchase

        :param purchase_id: The purchase Id (required)
        :type purchase_id: int
        :param tag_request: Tags to be removed from the purchase (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_delete_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_delete_serialize(
        self,
        purchase_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/tags/actions/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_get_airbill(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PurchaseNote:
        """purchases_get_airbill

        Retrieves a purchase's airbill

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_airbill_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_get_airbill_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PurchaseNote]:
        """purchases_get_airbill

        Retrieves a purchase's airbill

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_airbill_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_get_airbill_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_get_airbill

        Retrieves a purchase's airbill

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_airbill_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PurchaseNote",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_get_airbill_serialize(
        self,
        purchase_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/airbill',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_get_purchase_by_id(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Purchase:
        """purchases_get_purchase_by_id

        Retrieves a purchase by the purchase id

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_by_id_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_get_purchase_by_id_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Purchase]:
        """purchases_get_purchase_by_id

        Retrieves a purchase by the purchase id

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_by_id_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_get_purchase_by_id_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_get_purchase_by_id

        Retrieves a purchase by the purchase id

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_by_id_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_get_purchase_by_id_serialize(
        self,
        purchase_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_get_purchase_line(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """purchases_get_purchase_line

        Gets a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_get_purchase_line_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """purchases_get_purchase_line

        Gets a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_get_purchase_line_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_get_purchase_line

        Gets a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_get_purchase_line_serialize(
        self,
        purchase_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/lines/{line-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_get_purchase_line_tickets(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Ticket]:
        """purchases_get_purchase_line_tickets

        Gets the tickets of a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_tickets_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Ticket]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_get_purchase_line_tickets_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Ticket]]:
        """purchases_get_purchase_line_tickets

        Gets the tickets of a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_tickets_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Ticket]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_get_purchase_line_tickets_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_get_purchase_line_tickets

        Gets the tickets of a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_line_tickets_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Ticket]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_get_purchase_line_tickets_serialize(
        self,
        purchase_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/lines/{line-id}/tickets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_get_purchase_lines(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Line]:
        """purchases_get_purchase_lines

        Gets purchase lines

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_lines_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_get_purchase_lines_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Line]]:
        """purchases_get_purchase_lines

        Gets purchase lines

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_lines_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_get_purchase_lines_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_get_purchase_lines

        Gets purchase lines

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_get_purchase_lines_serialize(
            purchase_id=purchase_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_get_purchase_lines_serialize(
        self,
        purchase_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/lines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_insert_purchase(
        self,
        purchase: Annotated[Purchase, Field(description="A purchase object to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Purchase:
        """purchases_insert_purchase

        Creates a purchase. The minimum required field to insert a purchase is the vendorId. Inventory purchase lines must include quantity, section, row, cost, lowSeat, highSeat, stockType,  seatType and either an eventId or eventMapping.

        :param purchase: A purchase object to create. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_serialize(
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_insert_purchase_with_http_info(
        self,
        purchase: Annotated[Purchase, Field(description="A purchase object to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Purchase]:
        """purchases_insert_purchase

        Creates a purchase. The minimum required field to insert a purchase is the vendorId. Inventory purchase lines must include quantity, section, row, cost, lowSeat, highSeat, stockType,  seatType and either an eventId or eventMapping.

        :param purchase: A purchase object to create. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_serialize(
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_insert_purchase_without_preload_content(
        self,
        purchase: Annotated[Purchase, Field(description="A purchase object to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_insert_purchase

        Creates a purchase. The minimum required field to insert a purchase is the vendorId. Inventory purchase lines must include quantity, section, row, cost, lowSeat, highSeat, stockType,  seatType and either an eventId or eventMapping.

        :param purchase: A purchase object to create. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_serialize(
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_insert_purchase_serialize(
        self,
        purchase,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if purchase is not None:
            _body_params = purchase


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_insert_purchase_line(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line: Annotated[Line, Field(description="The purchase line to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """purchases_insert_purchase_line

        Adds a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line: The purchase line to add. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_line_serialize(
            purchase_id=purchase_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_insert_purchase_line_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line: Annotated[Line, Field(description="The purchase line to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """purchases_insert_purchase_line

        Adds a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line: The purchase line to add. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_line_serialize(
            purchase_id=purchase_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_insert_purchase_line_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line: Annotated[Line, Field(description="The purchase line to add.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_insert_purchase_line

        Adds a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line: The purchase line to add. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_insert_purchase_line_serialize(
            purchase_id=purchase_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_insert_purchase_line_serialize(
        self,
        purchase_id,
        line,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if line is not None:
            _body_params = line


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/lines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_multi_with_purchase_id(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase order id on which to attach the tickets")],
        inventory: Annotated[List[Inventory], Field(description="Array of inventory objects to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Inventory]:
        """purchases_multi_with_purchase_id

        Creates inventory

        :param purchase_id: The purchase order id on which to attach the tickets (required)
        :type purchase_id: int
        :param inventory: Array of inventory objects to create. (required)
        :type inventory: List[Inventory]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_multi_with_purchase_id_serialize(
            purchase_id=purchase_id,
            inventory=inventory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_multi_with_purchase_id_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase order id on which to attach the tickets")],
        inventory: Annotated[List[Inventory], Field(description="Array of inventory objects to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Inventory]]:
        """purchases_multi_with_purchase_id

        Creates inventory

        :param purchase_id: The purchase order id on which to attach the tickets (required)
        :type purchase_id: int
        :param inventory: Array of inventory objects to create. (required)
        :type inventory: List[Inventory]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_multi_with_purchase_id_serialize(
            purchase_id=purchase_id,
            inventory=inventory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_multi_with_purchase_id_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The purchase order id on which to attach the tickets")],
        inventory: Annotated[List[Inventory], Field(description="Array of inventory objects to create.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_multi_with_purchase_id

        Creates inventory

        :param purchase_id: The purchase order id on which to attach the tickets (required)
        :type purchase_id: int
        :param inventory: Array of inventory objects to create. (required)
        :type inventory: List[Inventory]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_multi_with_purchase_id_serialize(
            purchase_id=purchase_id,
            inventory=inventory,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Inventory]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_multi_with_purchase_id_serialize(
        self,
        purchase_id,
        inventory,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'Inventory': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if inventory is not None:
            _body_params = inventory


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_print(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_print

        Prints a Purchase Order

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_print_serialize(
            purchase_id=purchase_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_print_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_print

        Prints a Purchase Order

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_print_serialize(
            purchase_id=purchase_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_print_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_print

        Prints a Purchase Order

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_print_serialize(
            purchase_id=purchase_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_print_serialize(
        self,
        purchase_id,
        time_zone_offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        if time_zone_offset is not None:
            
            _query_params.append(('timeZoneOffset', time_zone_offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/print',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_remove_tag(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) purchases_remove_tag

        Deletes a tag for a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag: Tag to be removed from the purchase (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /purchases/{purchase-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._purchases_remove_tag_serialize(
            purchase_id=purchase_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_remove_tag_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) purchases_remove_tag

        Deletes a tag for a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag: Tag to be removed from the purchase (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /purchases/{purchase-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._purchases_remove_tag_serialize(
            purchase_id=purchase_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_remove_tag_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the purchase")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) purchases_remove_tag

        Deletes a tag for a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag: Tag to be removed from the purchase (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /purchases/{purchase-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._purchases_remove_tag_serialize(
            purchase_id=purchase_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_remove_tag_serialize(
        self,
        purchase_id,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if tag is not None:
            _path_params['tag'] = tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/purchases/{purchase-id}/tags/{tag}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_replace_purchase_line(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        purchase_line_replace_action: PurchaseLineReplaceAction,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """purchases_replace_purchase_line

        Replaces a purchase line. Allows changing section, row, low seat and seat type.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param purchase_line_replace_action: (required)
        :type purchase_line_replace_action: PurchaseLineReplaceAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_replace_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            purchase_line_replace_action=purchase_line_replace_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_replace_purchase_line_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        purchase_line_replace_action: PurchaseLineReplaceAction,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """purchases_replace_purchase_line

        Replaces a purchase line. Allows changing section, row, low seat and seat type.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param purchase_line_replace_action: (required)
        :type purchase_line_replace_action: PurchaseLineReplaceAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_replace_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            purchase_line_replace_action=purchase_line_replace_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_replace_purchase_line_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        purchase_line_replace_action: PurchaseLineReplaceAction,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_replace_purchase_line

        Replaces a purchase line. Allows changing section, row, low seat and seat type.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param purchase_line_replace_action: (required)
        :type purchase_line_replace_action: PurchaseLineReplaceAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_replace_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            purchase_line_replace_action=purchase_line_replace_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_replace_purchase_line_serialize(
        self,
        purchase_id,
        line_id,
        purchase_line_replace_action,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if purchase_line_replace_action is not None:
            _body_params = purchase_line_replace_action


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/lines/{line-id}/actions/replace',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_search(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        payment_method: Annotated[Optional[List[StrictStr]], Field(description="Payment method search filter")] = None,
        vendor_type: Annotated[Optional[List[StrictStr]], Field(description="Vendor type search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        vendor_tag: Optional[List[StrictStr]] = None,
        vendor_tags_match_all: Optional[StrictBool] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        inventory_id: Annotated[Optional[StrictInt], Field(description="Inventory Id search filter")] = None,
        invoice_line_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        credit_card_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Purchase creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Purchase creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Purchase last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Purchase last update date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        simplified_external_ref: Annotated[Optional[List[StrictStr]], Field(description="Simplified external reference (ignoring dashes, slashes or spaces) search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        min_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum cost search filter")] = None,
        max_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum cost search filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_has_zone_seating_inventory: Annotated[Optional[StrictBool], Field(description="Whether the results should include inventory zone seating")] = None,
        zero_outstanding_balance: Annotated[Optional[StrictBool], Field(description="Whether the results should have zero outstanding balance")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance search filter")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event Name search filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="User email for purchase creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id for purchase creator")] = None,
        last_purchase_payment_note: Annotated[Optional[StrictStr], Field(description="Last purchase payment note search filter")] = None,
        vendor_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PurchaseSummary]:
        """purchases_search

        Searches purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param payment_method: Payment method search filter
        :type payment_method: List[str]
        :param vendor_type: Vendor type search filter
        :type vendor_type: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param vendor_tag:
        :type vendor_tag: List[str]
        :param vendor_tags_match_all:
        :type vendor_tags_match_all: bool
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param id: Purchase Id search filter
        :type id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: int
        :param invoice_line_id: Invoice line Id search filter
        :type invoice_line_id: int
        :param credit_card_id: Invoice line Id search filter
        :type credit_card_id: int
        :param created_date_from: Purchase creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Purchase creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Purchase last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Purchase last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param simplified_external_ref: Simplified external reference (ignoring dashes, slashes or spaces) search filter
        :type simplified_external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param min_cost: Minimum cost search filter
        :type min_cost: float
        :param max_cost: Maximum cost search filter
        :type max_cost: float
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_has_zone_seating_inventory: Whether the results should include inventory zone seating
        :type include_has_zone_seating_inventory: bool
        :param zero_outstanding_balance: Whether the results should have zero outstanding balance
        :type zero_outstanding_balance: bool
        :param min_outstanding_balance: Minimum outstanding balance search filter
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance search filter
        :type max_outstanding_balance: float
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param event_name: Event Name search filter
        :type event_name: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param created_by: User email for purchase creator
        :type created_by: str
        :param created_by_user_id: User id for purchase creator
        :type created_by_user_id: int
        :param last_purchase_payment_note: Last purchase payment note search filter
        :type last_purchase_payment_note: str
        :param vendor_tags:
        :type vendor_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            payment_method=payment_method,
            vendor_type=vendor_type,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            vendor_tag=vendor_tag,
            vendor_tags_match_all=vendor_tags_match_all,
            vendor_id=vendor_id,
            display_name=display_name,
            id=id,
            inventory_id=inventory_id,
            invoice_line_id=invoice_line_id,
            credit_card_id=credit_card_id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            simplified_external_ref=simplified_external_ref,
            payment_status=payment_status,
            purchase_status=purchase_status,
            min_cost=min_cost,
            max_cost=max_cost,
            currency_code=currency_code,
            internal_id=internal_id,
            sorted_by=sorted_by,
            include_has_zone_seating_inventory=include_has_zone_seating_inventory,
            zero_outstanding_balance=zero_outstanding_balance,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            consignment=consignment,
            event_id=event_id,
            event_name=event_name,
            cooperative=cooperative,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            last_purchase_payment_note=last_purchase_payment_note,
            vendor_tags=vendor_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_search_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        payment_method: Annotated[Optional[List[StrictStr]], Field(description="Payment method search filter")] = None,
        vendor_type: Annotated[Optional[List[StrictStr]], Field(description="Vendor type search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        vendor_tag: Optional[List[StrictStr]] = None,
        vendor_tags_match_all: Optional[StrictBool] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        inventory_id: Annotated[Optional[StrictInt], Field(description="Inventory Id search filter")] = None,
        invoice_line_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        credit_card_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Purchase creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Purchase creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Purchase last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Purchase last update date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        simplified_external_ref: Annotated[Optional[List[StrictStr]], Field(description="Simplified external reference (ignoring dashes, slashes or spaces) search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        min_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum cost search filter")] = None,
        max_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum cost search filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_has_zone_seating_inventory: Annotated[Optional[StrictBool], Field(description="Whether the results should include inventory zone seating")] = None,
        zero_outstanding_balance: Annotated[Optional[StrictBool], Field(description="Whether the results should have zero outstanding balance")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance search filter")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event Name search filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="User email for purchase creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id for purchase creator")] = None,
        last_purchase_payment_note: Annotated[Optional[StrictStr], Field(description="Last purchase payment note search filter")] = None,
        vendor_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PurchaseSummary]]:
        """purchases_search

        Searches purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param payment_method: Payment method search filter
        :type payment_method: List[str]
        :param vendor_type: Vendor type search filter
        :type vendor_type: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param vendor_tag:
        :type vendor_tag: List[str]
        :param vendor_tags_match_all:
        :type vendor_tags_match_all: bool
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param id: Purchase Id search filter
        :type id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: int
        :param invoice_line_id: Invoice line Id search filter
        :type invoice_line_id: int
        :param credit_card_id: Invoice line Id search filter
        :type credit_card_id: int
        :param created_date_from: Purchase creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Purchase creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Purchase last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Purchase last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param simplified_external_ref: Simplified external reference (ignoring dashes, slashes or spaces) search filter
        :type simplified_external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param min_cost: Minimum cost search filter
        :type min_cost: float
        :param max_cost: Maximum cost search filter
        :type max_cost: float
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_has_zone_seating_inventory: Whether the results should include inventory zone seating
        :type include_has_zone_seating_inventory: bool
        :param zero_outstanding_balance: Whether the results should have zero outstanding balance
        :type zero_outstanding_balance: bool
        :param min_outstanding_balance: Minimum outstanding balance search filter
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance search filter
        :type max_outstanding_balance: float
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param event_name: Event Name search filter
        :type event_name: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param created_by: User email for purchase creator
        :type created_by: str
        :param created_by_user_id: User id for purchase creator
        :type created_by_user_id: int
        :param last_purchase_payment_note: Last purchase payment note search filter
        :type last_purchase_payment_note: str
        :param vendor_tags:
        :type vendor_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            payment_method=payment_method,
            vendor_type=vendor_type,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            vendor_tag=vendor_tag,
            vendor_tags_match_all=vendor_tags_match_all,
            vendor_id=vendor_id,
            display_name=display_name,
            id=id,
            inventory_id=inventory_id,
            invoice_line_id=invoice_line_id,
            credit_card_id=credit_card_id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            simplified_external_ref=simplified_external_ref,
            payment_status=payment_status,
            purchase_status=purchase_status,
            min_cost=min_cost,
            max_cost=max_cost,
            currency_code=currency_code,
            internal_id=internal_id,
            sorted_by=sorted_by,
            include_has_zone_seating_inventory=include_has_zone_seating_inventory,
            zero_outstanding_balance=zero_outstanding_balance,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            consignment=consignment,
            event_id=event_id,
            event_name=event_name,
            cooperative=cooperative,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            last_purchase_payment_note=last_purchase_payment_note,
            vendor_tags=vendor_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_search_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        payment_method: Annotated[Optional[List[StrictStr]], Field(description="Payment method search filter")] = None,
        vendor_type: Annotated[Optional[List[StrictStr]], Field(description="Vendor type search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        vendor_tag: Optional[List[StrictStr]] = None,
        vendor_tags_match_all: Optional[StrictBool] = None,
        vendor_id: Annotated[Optional[StrictInt], Field(description="Vendor Id search filter")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Vendor display name search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Purchase Id search filter")] = None,
        inventory_id: Annotated[Optional[StrictInt], Field(description="Inventory Id search filter")] = None,
        invoice_line_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        credit_card_id: Annotated[Optional[StrictInt], Field(description="Invoice line Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Purchase creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Purchase creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Purchase last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Purchase last update date to range filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        simplified_external_ref: Annotated[Optional[List[StrictStr]], Field(description="Simplified external reference (ignoring dashes, slashes or spaces) search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        purchase_status: Annotated[Optional[List[StrictStr]], Field(description="Purchase status search filter")] = None,
        min_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum cost search filter")] = None,
        max_cost: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum cost search filter")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_has_zone_seating_inventory: Annotated[Optional[StrictBool], Field(description="Whether the results should include inventory zone seating")] = None,
        zero_outstanding_balance: Annotated[Optional[StrictBool], Field(description="Whether the results should have zero outstanding balance")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance search filter")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance search filter")] = None,
        consignment: Annotated[Optional[StrictStr], Field(description="Whether the results have a consignment type POs")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event Name search filter")] = None,
        cooperative: Annotated[Optional[StrictBool], Field(description="Whether the results have cooperative POs")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="User email for purchase creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="User id for purchase creator")] = None,
        last_purchase_payment_note: Annotated[Optional[StrictStr], Field(description="Last purchase payment note search filter")] = None,
        vendor_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_search

        Searches purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param payment_method: Payment method search filter
        :type payment_method: List[str]
        :param vendor_type: Vendor type search filter
        :type vendor_type: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param vendor_tag:
        :type vendor_tag: List[str]
        :param vendor_tags_match_all:
        :type vendor_tags_match_all: bool
        :param vendor_id: Vendor Id search filter
        :type vendor_id: int
        :param display_name: Vendor display name search filter
        :type display_name: str
        :param id: Purchase Id search filter
        :type id: List[int]
        :param inventory_id: Inventory Id search filter
        :type inventory_id: int
        :param invoice_line_id: Invoice line Id search filter
        :type invoice_line_id: int
        :param credit_card_id: Invoice line Id search filter
        :type credit_card_id: int
        :param created_date_from: Purchase creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Purchase creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Purchase last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Purchase last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: str
        :param simplified_external_ref: Simplified external reference (ignoring dashes, slashes or spaces) search filter
        :type simplified_external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param purchase_status: Purchase status search filter
        :type purchase_status: List[str]
        :param min_cost: Minimum cost search filter
        :type min_cost: float
        :param max_cost: Maximum cost search filter
        :type max_cost: float
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_has_zone_seating_inventory: Whether the results should include inventory zone seating
        :type include_has_zone_seating_inventory: bool
        :param zero_outstanding_balance: Whether the results should have zero outstanding balance
        :type zero_outstanding_balance: bool
        :param min_outstanding_balance: Minimum outstanding balance search filter
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance search filter
        :type max_outstanding_balance: float
        :param consignment: Whether the results have a consignment type POs
        :type consignment: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param event_name: Event Name search filter
        :type event_name: str
        :param cooperative: Whether the results have cooperative POs
        :type cooperative: bool
        :param created_by: User email for purchase creator
        :type created_by: str
        :param created_by_user_id: User id for purchase creator
        :type created_by_user_id: int
        :param last_purchase_payment_note: Last purchase payment note search filter
        :type last_purchase_payment_note: str
        :param vendor_tags:
        :type vendor_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            payment_method=payment_method,
            vendor_type=vendor_type,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            vendor_tag=vendor_tag,
            vendor_tags_match_all=vendor_tags_match_all,
            vendor_id=vendor_id,
            display_name=display_name,
            id=id,
            inventory_id=inventory_id,
            invoice_line_id=invoice_line_id,
            credit_card_id=credit_card_id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            simplified_external_ref=simplified_external_ref,
            payment_status=payment_status,
            purchase_status=purchase_status,
            min_cost=min_cost,
            max_cost=max_cost,
            currency_code=currency_code,
            internal_id=internal_id,
            sorted_by=sorted_by,
            include_has_zone_seating_inventory=include_has_zone_seating_inventory,
            zero_outstanding_balance=zero_outstanding_balance,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            consignment=consignment,
            event_id=event_id,
            event_name=event_name,
            cooperative=cooperative,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            last_purchase_payment_note=last_purchase_payment_note,
            vendor_tags=vendor_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_search_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        delivery_method,
        payment_method,
        vendor_type,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        vendor_tag,
        vendor_tags_match_all,
        vendor_id,
        display_name,
        id,
        inventory_id,
        invoice_line_id,
        credit_card_id,
        created_date_from,
        created_date_to,
        last_update_from,
        last_update_to,
        external_ref,
        simplified_external_ref,
        payment_status,
        purchase_status,
        min_cost,
        max_cost,
        currency_code,
        internal_id,
        sorted_by,
        include_has_zone_seating_inventory,
        zero_outstanding_balance,
        min_outstanding_balance,
        max_outstanding_balance,
        consignment,
        event_id,
        event_name,
        cooperative,
        created_by,
        created_by_user_id,
        last_purchase_payment_note,
        vendor_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'deliveryMethod': 'multi',
            'paymentMethod': 'multi',
            'vendorType': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'vendorTag': 'multi',
            'id': 'multi',
            'simplifiedExternalRef': 'multi',
            'paymentStatus': 'multi',
            'purchaseStatus': 'multi',
            'eventId': 'multi',
            'vendorTags': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if delivery_method is not None:
            
            _query_params.append(('deliveryMethod', delivery_method))
            
        if payment_method is not None:
            
            _query_params.append(('paymentMethod', payment_method))
            
        if vendor_type is not None:
            
            _query_params.append(('vendorType', vendor_type))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if vendor_tag is not None:
            
            _query_params.append(('vendorTag', vendor_tag))
            
        if vendor_tags_match_all is not None:
            
            _query_params.append(('vendorTagsMatchAll', vendor_tags_match_all))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if display_name is not None:
            
            _query_params.append(('displayName', display_name))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if inventory_id is not None:
            
            _query_params.append(('inventoryId', inventory_id))
            
        if invoice_line_id is not None:
            
            _query_params.append(('invoiceLineId', invoice_line_id))
            
        if credit_card_id is not None:
            
            _query_params.append(('creditCardId', credit_card_id))
            
        if created_date_from is not None:
            if isinstance(created_date_from, datetime):
                _query_params.append(
                    (
                        'createdDateFrom',
                        created_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdDateFrom', created_date_from))
            
        if created_date_to is not None:
            if isinstance(created_date_to, datetime):
                _query_params.append(
                    (
                        'createdDateTo',
                        created_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdDateTo', created_date_to))
            
        if last_update_from is not None:
            if isinstance(last_update_from, datetime):
                _query_params.append(
                    (
                        'lastUpdateFrom',
                        last_update_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateFrom', last_update_from))
            
        if last_update_to is not None:
            if isinstance(last_update_to, datetime):
                _query_params.append(
                    (
                        'lastUpdateTo',
                        last_update_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateTo', last_update_to))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if simplified_external_ref is not None:
            
            _query_params.append(('simplifiedExternalRef', simplified_external_ref))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if purchase_status is not None:
            
            _query_params.append(('purchaseStatus', purchase_status))
            
        if min_cost is not None:
            
            _query_params.append(('minCost', min_cost))
            
        if max_cost is not None:
            
            _query_params.append(('maxCost', max_cost))
            
        if currency_code is not None:
            
            _query_params.append(('currencyCode', currency_code))
            
        if internal_id is not None:
            
            _query_params.append(('internalId', internal_id))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        if include_has_zone_seating_inventory is not None:
            
            _query_params.append(('includeHasZoneSeatingInventory', include_has_zone_seating_inventory))
            
        if zero_outstanding_balance is not None:
            
            _query_params.append(('zeroOutstandingBalance', zero_outstanding_balance))
            
        if min_outstanding_balance is not None:
            
            _query_params.append(('minOutstandingBalance', min_outstanding_balance))
            
        if max_outstanding_balance is not None:
            
            _query_params.append(('maxOutstandingBalance', max_outstanding_balance))
            
        if consignment is not None:
            
            _query_params.append(('consignment', consignment))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if event_name is not None:
            
            _query_params.append(('eventName', event_name))
            
        if cooperative is not None:
            
            _query_params.append(('cooperative', cooperative))
            
        if created_by is not None:
            
            _query_params.append(('createdBy', created_by))
            
        if created_by_user_id is not None:
            
            _query_params.append(('createdByUserId', created_by_user_id))
            
        if last_purchase_payment_note is not None:
            
            _query_params.append(('lastPurchasePaymentNote', last_purchase_payment_note))
            
        if vendor_tags is not None:
            
            _query_params.append(('vendorTags', vendor_tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_search_auto_purchases(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        event_id: Annotated[Optional[StrictInt], Field(description="Event Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        user: Annotated[Optional[StrictStr], Field(description="User email search filter")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="User id search filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        from_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        to_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event name search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        ticket_status: Annotated[Optional[StrictStr], Field(description="Ticket Status search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PurchaseSummary]:
        """purchases_search_auto_purchases

        Searches auto purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param event_id: Event Id search filter
        :type event_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param user: User email search filter
        :type user: str
        :param user_id: User id search filter
        :type user_id: int
        :param external_ref: External reference search filter
        :type external_ref: str
        :param from_purchase_date: Purchase date from range filter
        :type from_purchase_date: datetime
        :param to_purchase_date: Purchase date to range filter
        :type to_purchase_date: datetime
        :param event_name: Event name search filter
        :type event_name: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: str
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_auto_purchases_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            event_id=event_id,
            purchase_id=purchase_id,
            user=user,
            user_id=user_id,
            external_ref=external_ref,
            from_purchase_date=from_purchase_date,
            to_purchase_date=to_purchase_date,
            event_name=event_name,
            venue_id=venue_id,
            venue=venue,
            ticket_status=ticket_status,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_search_auto_purchases_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        event_id: Annotated[Optional[StrictInt], Field(description="Event Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        user: Annotated[Optional[StrictStr], Field(description="User email search filter")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="User id search filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        from_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        to_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event name search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        ticket_status: Annotated[Optional[StrictStr], Field(description="Ticket Status search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PurchaseSummary]]:
        """purchases_search_auto_purchases

        Searches auto purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param event_id: Event Id search filter
        :type event_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param user: User email search filter
        :type user: str
        :param user_id: User id search filter
        :type user_id: int
        :param external_ref: External reference search filter
        :type external_ref: str
        :param from_purchase_date: Purchase date from range filter
        :type from_purchase_date: datetime
        :param to_purchase_date: Purchase date to range filter
        :type to_purchase_date: datetime
        :param event_name: Event name search filter
        :type event_name: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: str
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_auto_purchases_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            event_id=event_id,
            purchase_id=purchase_id,
            user=user,
            user_id=user_id,
            external_ref=external_ref,
            from_purchase_date=from_purchase_date,
            to_purchase_date=to_purchase_date,
            event_name=event_name,
            venue_id=venue_id,
            venue=venue,
            ticket_status=ticket_status,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_search_auto_purchases_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        event_id: Annotated[Optional[StrictInt], Field(description="Event Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        user: Annotated[Optional[StrictStr], Field(description="User email search filter")] = None,
        user_id: Annotated[Optional[StrictInt], Field(description="User id search filter")] = None,
        external_ref: Annotated[Optional[StrictStr], Field(description="External reference search filter")] = None,
        from_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        to_purchase_date: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        event_name: Annotated[Optional[StrictStr], Field(description="Event name search filter")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        ticket_status: Annotated[Optional[StrictStr], Field(description="Ticket Status search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_search_auto_purchases

        Searches auto purchases

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param event_id: Event Id search filter
        :type event_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param user: User email search filter
        :type user: str
        :param user_id: User id search filter
        :type user_id: int
        :param external_ref: External reference search filter
        :type external_ref: str
        :param from_purchase_date: Purchase date from range filter
        :type from_purchase_date: datetime
        :param to_purchase_date: Purchase date to range filter
        :type to_purchase_date: datetime
        :param event_name: Event name search filter
        :type event_name: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param ticket_status: Ticket Status search filter
        :type ticket_status: str
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_search_auto_purchases_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            event_id=event_id,
            purchase_id=purchase_id,
            user=user,
            user_id=user_id,
            external_ref=external_ref,
            from_purchase_date=from_purchase_date,
            to_purchase_date=to_purchase_date,
            event_name=event_name,
            venue_id=venue_id,
            venue=venue,
            ticket_status=ticket_status,
            sorted_by=sorted_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PurchaseSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_search_auto_purchases_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        event_id,
        purchase_id,
        user,
        user_id,
        external_ref,
        from_purchase_date,
        to_purchase_date,
        event_name,
        venue_id,
        venue,
        ticket_status,
        sorted_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if purchase_id is not None:
            
            _query_params.append(('purchaseId', purchase_id))
            
        if user is not None:
            
            _query_params.append(('user', user))
            
        if user_id is not None:
            
            _query_params.append(('userId', user_id))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if from_purchase_date is not None:
            if isinstance(from_purchase_date, datetime):
                _query_params.append(
                    (
                        'fromPurchaseDate',
                        from_purchase_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fromPurchaseDate', from_purchase_date))
            
        if to_purchase_date is not None:
            if isinstance(to_purchase_date, datetime):
                _query_params.append(
                    (
                        'toPurchaseDate',
                        to_purchase_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('toPurchaseDate', to_purchase_date))
            
        if event_name is not None:
            
            _query_params.append(('eventName', event_name))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if ticket_status is not None:
            
            _query_params.append(('ticketStatus', ticket_status))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/auto-purchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_send(
        self,
        purchase_id: Annotated[int, Field(strict=True, ge=1, description="Id of the purchase")],
        email_address: Annotated[List[StrictStr], Field(description="The vendor's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_airbill: Annotated[Optional[StrictBool], Field(description="Whether the email includes the airbill PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_send

        Sends a Purchase Order to the vendor's email address

        :param purchase_id: Id of the purchase (required)
        :type purchase_id: int
        :param email_address: The vendor's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The vendor's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The vendor's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_airbill: Whether the email includes the airbill PDF attached
        :type include_airbill: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_send_serialize(
            purchase_id=purchase_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_airbill=include_airbill,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_send_with_http_info(
        self,
        purchase_id: Annotated[int, Field(strict=True, ge=1, description="Id of the purchase")],
        email_address: Annotated[List[StrictStr], Field(description="The vendor's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_airbill: Annotated[Optional[StrictBool], Field(description="Whether the email includes the airbill PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_send

        Sends a Purchase Order to the vendor's email address

        :param purchase_id: Id of the purchase (required)
        :type purchase_id: int
        :param email_address: The vendor's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The vendor's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The vendor's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_airbill: Whether the email includes the airbill PDF attached
        :type include_airbill: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_send_serialize(
            purchase_id=purchase_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_airbill=include_airbill,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_send_without_preload_content(
        self,
        purchase_id: Annotated[int, Field(strict=True, ge=1, description="Id of the purchase")],
        email_address: Annotated[List[StrictStr], Field(description="The vendor's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The vendor's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_airbill: Annotated[Optional[StrictBool], Field(description="Whether the email includes the airbill PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_send

        Sends a Purchase Order to the vendor's email address

        :param purchase_id: Id of the purchase (required)
        :type purchase_id: int
        :param email_address: The vendor's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The vendor's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The vendor's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_airbill: Whether the email includes the airbill PDF attached
        :type include_airbill: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_send_serialize(
            purchase_id=purchase_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_airbill=include_airbill,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_send_serialize(
        self,
        purchase_id,
        email_address,
        cc_email_address,
        bcc_email_address,
        subject,
        message,
        include_airbill,
        time_zone_offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'emailAddress': 'multi',
            'ccEmailAddress': 'multi',
            'bccEmailAddress': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if cc_email_address is not None:
            
            _query_params.append(('ccEmailAddress', cc_email_address))
            
        if bcc_email_address is not None:
            
            _query_params.append(('bccEmailAddress', bcc_email_address))
            
        if subject is not None:
            
            _query_params.append(('subject', subject))
            
        if message is not None:
            
            _query_params.append(('message', message))
            
        if include_airbill is not None:
            
            _query_params.append(('includeAirbill', include_airbill))
            
        if time_zone_offset is not None:
            
            _query_params.append(('timeZoneOffset', time_zone_offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/purchases/{purchase-id}/send',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_tag(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_tag

        Inserts a new tags for a purchase. Duplicates are ignored.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_tag_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_tag_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_tag

        Inserts a new tags for a purchase. Duplicates are ignored.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_tag_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_tag_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_tag

        Inserts a new tags for a purchase. Duplicates are ignored.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_tag_serialize(
            purchase_id=purchase_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_tag_serialize(
        self,
        purchase_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_update(
        self,
        bulk_purchase_update: Annotated[BulkPurchaseUpdate, Field(description="Bulk purchase update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_update

        Bulk Purchase Update

        :param bulk_purchase_update: Bulk purchase update (required)
        :type bulk_purchase_update: BulkPurchaseUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_serialize(
            bulk_purchase_update=bulk_purchase_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_update_with_http_info(
        self,
        bulk_purchase_update: Annotated[BulkPurchaseUpdate, Field(description="Bulk purchase update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_update

        Bulk Purchase Update

        :param bulk_purchase_update: Bulk purchase update (required)
        :type bulk_purchase_update: BulkPurchaseUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_serialize(
            bulk_purchase_update=bulk_purchase_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_update_without_preload_content(
        self,
        bulk_purchase_update: Annotated[BulkPurchaseUpdate, Field(description="Bulk purchase update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_update

        Bulk Purchase Update

        :param bulk_purchase_update: Bulk purchase update (required)
        :type bulk_purchase_update: BulkPurchaseUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_serialize(
            bulk_purchase_update=bulk_purchase_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_update_serialize(
        self,
        bulk_purchase_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_purchase_update is not None:
            _body_params = bulk_purchase_update



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/purchases/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_update_currency(
        self,
        currency_update_bulk_action: Annotated[CurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_update_currency

        Converts purchases currency using an exchange rate

        :param currency_update_bulk_action: Payload for bulk action (required)
        :type currency_update_bulk_action: CurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_currency_serialize(
            currency_update_bulk_action=currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_update_currency_with_http_info(
        self,
        currency_update_bulk_action: Annotated[CurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_update_currency

        Converts purchases currency using an exchange rate

        :param currency_update_bulk_action: Payload for bulk action (required)
        :type currency_update_bulk_action: CurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_currency_serialize(
            currency_update_bulk_action=currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_update_currency_without_preload_content(
        self,
        currency_update_bulk_action: Annotated[CurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_update_currency

        Converts purchases currency using an exchange rate

        :param currency_update_bulk_action: Payload for bulk action (required)
        :type currency_update_bulk_action: CurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_currency_serialize(
            currency_update_bulk_action=currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_update_currency_serialize(
        self,
        currency_update_bulk_action,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if currency_update_bulk_action is not None:
            _body_params = currency_update_bulk_action



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/purchases/actions/update-purchase-currency',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_update_purchase(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase: Annotated[Purchase, Field(description="A purchase object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Purchase:
        """purchases_update_purchase

        Updates a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase: A purchase object to update. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_serialize(
            purchase_id=purchase_id,
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_update_purchase_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase: Annotated[Purchase, Field(description="A purchase object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Purchase]:
        """purchases_update_purchase

        Updates a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase: A purchase object to update. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_serialize(
            purchase_id=purchase_id,
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_update_purchase_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        purchase: Annotated[Purchase, Field(description="A purchase object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_update_purchase

        Updates a purchase

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param purchase: A purchase object to update. (required)
        :type purchase: Purchase
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_serialize(
            purchase_id=purchase_id,
            purchase=purchase,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Purchase",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_update_purchase_serialize(
        self,
        purchase_id,
        purchase,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if purchase is not None:
            _body_params = purchase


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/purchases/{purchase-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_update_purchase_inventory(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """purchases_update_purchase_inventory

        Updates section and row for a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_inventory_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_update_purchase_inventory_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """purchases_update_purchase_inventory

        Updates section and row for a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_inventory_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_update_purchase_inventory_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        update_purchase_inventory_request: UpdatePurchaseInventoryRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_update_purchase_inventory

        Updates section and row for a purchase line

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param update_purchase_inventory_request: (required)
        :type update_purchase_inventory_request: UpdatePurchaseInventoryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_inventory_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            update_purchase_inventory_request=update_purchase_inventory_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_update_purchase_inventory_serialize(
        self,
        purchase_id,
        line_id,
        update_purchase_inventory_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_purchase_inventory_request is not None:
            _body_params = update_purchase_inventory_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchases/{purchase-id}/lines/{line-id}/inventory',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def purchases_update_purchase_line(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        line: Annotated[Line, Field(description="A purchase line object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """purchases_update_purchase_line

        Updates a purchase line. Only amount and description can be updated.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param line: A purchase line object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def purchases_update_purchase_line_with_http_info(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        line: Annotated[Line, Field(description="A purchase line object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """purchases_update_purchase_line

        Updates a purchase line. Only amount and description can be updated.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param line: A purchase line object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def purchases_update_purchase_line_without_preload_content(
        self,
        purchase_id: Annotated[StrictInt, Field(description="The id of the purchase")],
        line_id: Annotated[StrictInt, Field(description="The line id of the purchase")],
        line: Annotated[Line, Field(description="A purchase line object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """purchases_update_purchase_line

        Updates a purchase line. Only amount and description can be updated.

        :param purchase_id: The id of the purchase (required)
        :type purchase_id: int
        :param line_id: The line id of the purchase (required)
        :type line_id: int
        :param line: A purchase line object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._purchases_update_purchase_line_serialize(
            purchase_id=purchase_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _purchases_update_purchase_line_serialize(
        self,
        purchase_id,
        line_id,
        line,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if purchase_id is not None:
            _path_params['purchase-id'] = purchase_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if line is not None:
            _body_params = line


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/purchases/{purchase-id}/lines/{line-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


