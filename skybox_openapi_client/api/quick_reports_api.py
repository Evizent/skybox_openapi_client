# coding: utf-8

"""
    SkyBox API

    The SkyBox APIs allow our users to create, update, delete, and export information within the SkyBox platform. These APIs allow SkyBox to be extensible, giving you the flexibility to grow, develop, and integrate third-party tooling to help scale out your business. To begin using the SkyBox APIs, you will need to generate two unique tokens: an Application_Token and an API Token.  To request a unique Application_Token, click here (<a href='https://skybox.vividseats.com/application-sign-up'>https://skybox.vividseats.com/application-sign-up</a>) and refer to this <a href='https://skybox.zendesk.com/hc/en-us/articles/6769735238043-Getting-Started-with-Skybox-APIs'>Zendesk Article</a> for detailed instructions on getting started with SkyBox APIs.  To generate an API Token when logged in to SkyBox, click on the drop-down under 'Logged In As:', select 'External Accounts', and then select 'API Invitation +'. A modal will appear and you will be prompted to enter the email address to which you want the token sent as well as to provide a brief description of the account.  Once you have both your Application_Token and API Token, there are two ways in which you can make requests: through the UI and through a third party. See below for detailed steps for each process.  Requests through the UI:  To begin, enter your Account ID in the X-Account field. Once complete, select _Authorize_. Next, enter your API Token in the X-Api-Token field. If you do not currently have an API Token, please follow the steps above to request one. Once complete, select _Authorize_. Last, enter your Application_Token in the X-Application-Token field. If you do not have an Application_Token, a sample is provided or you can follow the link above to request one. Once complete, select _Authorize_.  Requests through a third party (i.e. Postman):  The same information is required as it is through the UI, but it will be passed in through headers. It should look something like this:  X-Account: Account ID goes here!  X-Api-Token: API Token goes here!  X-Application-Token: Application_Token goes here!  Once these three items are successfully passed in as headers, you will be able to make sample requests.  <h2><a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>API Rate Limits</a> </h2>  A rate limit consists of two variables: an interval and a limit. An interval is a period of time, measured in seconds. A limit is the number of calls that can be made to an endpoint in an interval.  For example, SkyBox’s ‘GET /reports/‘ endpoint has an interval of 1 second and a limit of 1 call per interval. This means that this endpoint has a rate limit of 1 call/second.  Each endpoint, and its respective rate limit, is displayed in this <a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>Support Article</a>. If the endpoint is not listed, its rate limit is the default, indicated by the ‘*’ at the bottom of the table. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated

from skybox_openapi_client.api_client import ApiClient, RequestSerialized
from skybox_openapi_client.api_response import ApiResponse
from skybox_openapi_client.rest import RESTResponseType


class QuickReportsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def quick_reports_get_purchases(
        self,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """quick_reports_get_purchases

        Retrieves the purchases quick report

        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_purchases_serialize(
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def quick_reports_get_purchases_with_http_info(
        self,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """quick_reports_get_purchases

        Retrieves the purchases quick report

        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_purchases_serialize(
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def quick_reports_get_purchases_without_preload_content(
        self,
        purchase_date_from: Annotated[Optional[datetime], Field(description="Purchase date from range filter")] = None,
        purchase_date_to: Annotated[Optional[datetime], Field(description="Purchase date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """quick_reports_get_purchases

        Retrieves the purchases quick report

        :param purchase_date_from: Purchase date from range filter
        :type purchase_date_from: datetime
        :param purchase_date_to: Purchase date to range filter
        :type purchase_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_purchases_serialize(
            purchase_date_from=purchase_date_from,
            purchase_date_to=purchase_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _quick_reports_get_purchases_serialize(
        self,
        purchase_date_from,
        purchase_date_to,
        performer_id,
        category_id,
        event,
        venue,
        event_date_from,
        event_date_to,
        payment_status,
        inventory_tag,
        inventory_tags_match_all,
        inventory_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'categoryId': 'multi',
            'inventoryTag': 'multi',
            'inventoryTags': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if purchase_date_from is not None:
            if isinstance(purchase_date_from, datetime):
                _query_params.append(
                    (
                        'purchaseDateFrom',
                        purchase_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateFrom', purchase_date_from))
            
        if purchase_date_to is not None:
            if isinstance(purchase_date_to, datetime):
                _query_params.append(
                    (
                        'purchaseDateTo',
                        purchase_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('purchaseDateTo', purchase_date_to))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if inventory_tag is not None:
            
            _query_params.append(('inventoryTag', inventory_tag))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if inventory_tags is not None:
            
            _query_params.append(('inventoryTags', inventory_tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/quick-report/purchases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def quick_reports_get_sales(
        self,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """quick_reports_get_sales

        Retrieves the sales quick report

        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_sales_serialize(
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            fulfillment_status=fulfillment_status,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def quick_reports_get_sales_with_http_info(
        self,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """quick_reports_get_sales

        Retrieves the sales quick report

        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_sales_serialize(
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            fulfillment_status=fulfillment_status,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def quick_reports_get_sales_without_preload_content(
        self,
        invoice_date_from: Annotated[Optional[datetime], Field(description="Invoice date from range filter")] = None,
        invoice_date_to: Annotated[Optional[datetime], Field(description="Invoice date to range filter")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        category_id: Annotated[Optional[List[StrictInt]], Field(description="Category Id search filter")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Event to filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="From event date filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="To event date filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        payment_status: Annotated[Optional[StrictStr], Field(description="Payment status search filter")] = None,
        inventory_tag: Annotated[Optional[List[StrictStr]], Field(description="Inventory tags to include")] = None,
        inventory_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all inventory tags or only some")] = None,
        inventory_tags: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """quick_reports_get_sales

        Retrieves the sales quick report

        :param invoice_date_from: Invoice date from range filter
        :type invoice_date_from: datetime
        :param invoice_date_to: Invoice date to range filter
        :type invoice_date_to: datetime
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param category_id: Category Id search filter
        :type category_id: List[int]
        :param event: Event to filter
        :type event: str
        :param venue: Venue filter
        :type venue: str
        :param event_date_from: From event date filter
        :type event_date_from: datetime
        :param event_date_to: To event date filter
        :type event_date_to: datetime
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param payment_status: Payment status search filter
        :type payment_status: str
        :param inventory_tag: Inventory tags to include
        :type inventory_tag: List[str]
        :param inventory_tags_match_all: Whether the results should have all inventory tags or only some
        :type inventory_tags_match_all: bool
        :param inventory_tags:
        :type inventory_tags: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._quick_reports_get_sales_serialize(
            invoice_date_from=invoice_date_from,
            invoice_date_to=invoice_date_to,
            performer_id=performer_id,
            category_id=category_id,
            event=event,
            venue=venue,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            fulfillment_status=fulfillment_status,
            payment_status=payment_status,
            inventory_tag=inventory_tag,
            inventory_tags_match_all=inventory_tags_match_all,
            inventory_tags=inventory_tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _quick_reports_get_sales_serialize(
        self,
        invoice_date_from,
        invoice_date_to,
        performer_id,
        category_id,
        event,
        venue,
        event_date_from,
        event_date_to,
        fulfillment_status,
        payment_status,
        inventory_tag,
        inventory_tags_match_all,
        inventory_tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'categoryId': 'multi',
            'inventoryTag': 'multi',
            'inventoryTags': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if invoice_date_from is not None:
            if isinstance(invoice_date_from, datetime):
                _query_params.append(
                    (
                        'invoiceDateFrom',
                        invoice_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('invoiceDateFrom', invoice_date_from))
            
        if invoice_date_to is not None:
            if isinstance(invoice_date_to, datetime):
                _query_params.append(
                    (
                        'invoiceDateTo',
                        invoice_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('invoiceDateTo', invoice_date_to))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if fulfillment_status is not None:
            
            _query_params.append(('fulfillmentStatus', fulfillment_status))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if inventory_tag is not None:
            
            _query_params.append(('inventoryTag', inventory_tag))
            
        if inventory_tags_match_all is not None:
            
            _query_params.append(('inventoryTagsMatchAll', inventory_tags_match_all))
            
        if inventory_tags is not None:
            
            _query_params.append(('inventoryTags', inventory_tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/quick-report/sales',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


