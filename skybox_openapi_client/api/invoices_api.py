# coding: utf-8

"""
    SkyBox API

    The SkyBox APIs allow our users to create, update, delete, and export information within the SkyBox platform. These APIs allow SkyBox to be extensible, giving you the flexibility to grow, develop, and integrate third-party tooling to help scale out your business. To begin using the SkyBox APIs, you will need to generate two unique tokens: an Application_Token and an API Token.  To request a unique Application_Token, click here (<a href='https://skybox.vividseats.com/application-sign-up'>https://skybox.vividseats.com/application-sign-up</a>) and refer to this <a href='https://skybox.zendesk.com/hc/en-us/articles/6769735238043-Getting-Started-with-Skybox-APIs'>Zendesk Article</a> for detailed instructions on getting started with SkyBox APIs.  To generate an API Token when logged in to SkyBox, click on the drop-down under 'Logged In As:', select 'External Accounts', and then select 'API Invitation +'. A modal will appear and you will be prompted to enter the email address to which you want the token sent as well as to provide a brief description of the account.  Once you have both your Application_Token and API Token, there are two ways in which you can make requests: through the UI and through a third party. See below for detailed steps for each process.  Requests through the UI:  To begin, enter your Account ID in the X-Account field. Once complete, select _Authorize_. Next, enter your API Token in the X-Api-Token field. If you do not currently have an API Token, please follow the steps above to request one. Once complete, select _Authorize_. Last, enter your Application_Token in the X-Application-Token field. If you do not have an Application_Token, a sample is provided or you can follow the link above to request one. Once complete, select _Authorize_.  Requests through a third party (i.e. Postman):  The same information is required as it is through the UI, but it will be passed in through headers. It should look something like this:  X-Account: Account ID goes here!  X-Api-Token: API Token goes here!  X-Application-Token: Application_Token goes here!  Once these three items are successfully passed in as headers, you will be able to make sample requests.  <h2><a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>API Rate Limits</a> </h2>  A rate limit consists of two variables: an interval and a limit. An interval is a period of time, measured in seconds. A limit is the number of calls that can be made to an endpoint in an interval.  For example, SkyBox’s ‘GET /reports/‘ endpoint has an interval of 1 second and a limit of 1 call per interval. This means that this endpoint has a rate limit of 1 call/second.  Each endpoint, and its respective rate limit, is displayed in this <a href='https://skybox.zendesk.com/hc/en-us/articles/5999881334427-SkyBox-API-Rate-Limits'>Support Article</a>. If the endpoint is not listed, its rate limit is the default, indicated by the ‘*’ at the bottom of the table. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from skybox_openapi_client.models.bulk_invoice_update import BulkInvoiceUpdate
from skybox_openapi_client.models.invoice import Invoice
from skybox_openapi_client.models.invoice_currency_update_bulk_action import InvoiceCurrencyUpdateBulkAction
from skybox_openapi_client.models.invoice_summary import InvoiceSummary
from skybox_openapi_client.models.invoice_ticket import InvoiceTicket
from skybox_openapi_client.models.line import Line
from skybox_openapi_client.models.payment import Payment
from skybox_openapi_client.models.refund_request import RefundRequest
from skybox_openapi_client.models.tag_request import TagRequest
from skybox_openapi_client.models.ticket import Ticket

from skybox_openapi_client.api_client import ApiClient, RequestSerialized
from skybox_openapi_client.api_response import ApiResponse
from skybox_openapi_client.rest import RESTResponseType


class InvoicesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def invoices_bulk_remove_tags(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Invoice Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_bulk_remove_tags

        Deletes all tags from invoices with given ids

        :param request_body: Invoice Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_bulk_remove_tags_with_http_info(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Invoice Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_bulk_remove_tags

        Deletes all tags from invoices with given ids

        :param request_body: Invoice Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_bulk_remove_tags_without_preload_content(
        self,
        request_body: Annotated[List[StrictInt], Field(description="Invoice Ids")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_bulk_remove_tags

        Deletes all tags from invoices with given ids

        :param request_body: Invoice Ids (required)
        :type request_body: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_bulk_remove_tags_serialize(
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_bulk_remove_tags_serialize(
        self,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'request_body': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/tags/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_delete(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_delete

        Deletes tags for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag_request: Tags to be removed from the invoice (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_delete_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_delete

        Deletes tags for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag_request: Tags to be removed from the invoice (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_delete_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_delete

        Deletes tags for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag_request: Tags to be removed from the invoice (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_delete_serialize(
        self,
        invoice_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/{invoice-id}/tags/actions/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_delete_invoice_line(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_delete_invoice_line

        Deletes an invoice line. Tickets are returned back to the inventory pool.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_delete_invoice_line_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_delete_invoice_line

        Deletes an invoice line. Tickets are returned back to the inventory pool.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_delete_invoice_line_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_delete_invoice_line

        Deletes an invoice line. Tickets are returned back to the inventory pool.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_delete_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_delete_invoice_line_serialize(
        self,
        invoice_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/invoices/{invoice-id}/lines/{line-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_assets(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> str:
        """invoices_get_assets

        Gets invoice assets

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_assets_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_assets_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[str]:
        """invoices_get_assets

        Gets invoice assets

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_assets_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_assets_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_assets

        Gets invoice assets

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_assets_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "str",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_assets_serialize(
        self,
        invoice_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/assets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_invoice_by_id(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Invoice:
        """invoices_get_invoice_by_id

        Retrieves an invoice by the invoice id

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_by_id_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_invoice_by_id_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Invoice]:
        """invoices_get_invoice_by_id

        Retrieves an invoice by the invoice id

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_by_id_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_invoice_by_id_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_invoice_by_id

        Retrieves an invoice by the invoice id

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_by_id_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_invoice_by_id_serialize(
        self,
        invoice_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_invoice_line(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """invoices_get_invoice_line

        Gets an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_invoice_line_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """invoices_get_invoice_line

        Gets an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_invoice_line_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_invoice_line

        Gets an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_invoice_line_serialize(
        self,
        invoice_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/lines/{line-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_invoice_line_tickets(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Ticket:
        """invoices_get_invoice_line_tickets

        Get tickets for inventory

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_tickets_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Ticket",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_invoice_line_tickets_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Ticket]:
        """invoices_get_invoice_line_tickets

        Get tickets for inventory

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_tickets_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Ticket",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_invoice_line_tickets_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_invoice_line_tickets

        Get tickets for inventory

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_line_tickets_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Ticket",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_invoice_line_tickets_serialize(
        self,
        invoice_id,
        line_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/lines/{line-id}/tickets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_invoice_lines(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Line]:
        """invoices_get_invoice_lines

        Gets invoice lines

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_lines_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_invoice_lines_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Line]]:
        """invoices_get_invoice_lines

        Gets invoice lines

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_lines_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_invoice_lines_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_invoice_lines

        Gets invoice lines

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_lines_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Line]",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_invoice_lines_serialize(
        self,
        invoice_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/lines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_invoice_tickets_by_external_ref_v2(
        self,
        external_ref: Annotated[StrictStr, Field(description="The external ref of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InvoiceTicket]:
        """invoices_get_invoice_tickets_by_external_ref_v2

        Returns tickets on an invoice by external ref

        :param external_ref: The external ref of the invoice (required)
        :type external_ref: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_tickets_by_external_ref_v2_serialize(
            external_ref=external_ref,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceTicket]",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_invoice_tickets_by_external_ref_v2_with_http_info(
        self,
        external_ref: Annotated[StrictStr, Field(description="The external ref of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InvoiceTicket]]:
        """invoices_get_invoice_tickets_by_external_ref_v2

        Returns tickets on an invoice by external ref

        :param external_ref: The external ref of the invoice (required)
        :type external_ref: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_tickets_by_external_ref_v2_serialize(
            external_ref=external_ref,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceTicket]",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_invoice_tickets_by_external_ref_v2_without_preload_content(
        self,
        external_ref: Annotated[StrictStr, Field(description="The external ref of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_invoice_tickets_by_external_ref_v2

        Returns tickets on an invoice by external ref

        :param external_ref: The external ref of the invoice (required)
        :type external_ref: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_invoice_tickets_by_external_ref_v2_serialize(
            external_ref=external_ref,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceTicket]",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_invoice_tickets_by_external_ref_v2_serialize(
        self,
        external_ref,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if external_ref is not None:
            
            _query_params.append(('external-ref', external_ref))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/external-ref',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_get_transaction_history(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_get_transaction_history

        List all transactions appearing on an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_transaction_history_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_get_transaction_history_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_get_transaction_history

        List all transactions appearing on an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_transaction_history_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_get_transaction_history_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_get_transaction_history

        List all transactions appearing on an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_get_transaction_history_serialize(
            invoice_id=invoice_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_get_transaction_history_serialize(
        self,
        invoice_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/transactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_insert_invoice(
        self,
        invoice: Annotated[Invoice, Field(description="An invoice object to create.")],
        force: Annotated[Optional[StrictBool], Field(description="Whether is forced to invoice held inventory")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Invoice:
        """invoices_insert_invoice

        Creates an invoice. The minimum fields required for creating an invoices are customerId, lines, line.amount, line.itemIds, line.lineItemType.

        :param invoice: An invoice object to create. (required)
        :type invoice: Invoice
        :param force: Whether is forced to invoice held inventory
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_serialize(
            invoice=invoice,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_insert_invoice_with_http_info(
        self,
        invoice: Annotated[Invoice, Field(description="An invoice object to create.")],
        force: Annotated[Optional[StrictBool], Field(description="Whether is forced to invoice held inventory")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Invoice]:
        """invoices_insert_invoice

        Creates an invoice. The minimum fields required for creating an invoices are customerId, lines, line.amount, line.itemIds, line.lineItemType.

        :param invoice: An invoice object to create. (required)
        :type invoice: Invoice
        :param force: Whether is forced to invoice held inventory
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_serialize(
            invoice=invoice,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_insert_invoice_without_preload_content(
        self,
        invoice: Annotated[Invoice, Field(description="An invoice object to create.")],
        force: Annotated[Optional[StrictBool], Field(description="Whether is forced to invoice held inventory")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_insert_invoice

        Creates an invoice. The minimum fields required for creating an invoices are customerId, lines, line.amount, line.itemIds, line.lineItemType.

        :param invoice: An invoice object to create. (required)
        :type invoice: Invoice
        :param force: Whether is forced to invoice held inventory
        :type force: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_serialize(
            invoice=invoice,
            force=force,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_insert_invoice_serialize(
        self,
        invoice,
        force,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if force is not None:
            
            _query_params.append(('force', force))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if invoice is not None:
            _body_params = invoice


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_insert_invoice_line(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """invoices_insert_invoice_line

        Adds an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_line_serialize(
            invoice_id=invoice_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_insert_invoice_line_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """invoices_insert_invoice_line

        Adds an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_line_serialize(
            invoice_id=invoice_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_insert_invoice_line_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_insert_invoice_line

        Adds an invoice line

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_insert_invoice_line_serialize(
            invoice_id=invoice_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_insert_invoice_line_serialize(
        self,
        invoice_id,
        line,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if line is not None:
            _body_params = line


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/{invoice-id}/lines',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_print(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_print

        Prints an Invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_print_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_print

        Prints an Invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_print_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_print

        Prints an Invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_print_serialize(
        self,
        invoice_id,
        time_zone_offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        if time_zone_offset is not None:
            
            _query_params.append(('timeZoneOffset', time_zone_offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/print',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_print_custom_auth_form(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_print_custom_auth_form

        Prints an Invoice Custom Auth Form

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_custom_auth_form_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_print_custom_auth_form_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_print_custom_auth_form

        Prints an Invoice Custom Auth Form

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_custom_auth_form_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_print_custom_auth_form_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_print_custom_auth_form

        Prints an Invoice Custom Auth Form

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_print_custom_auth_form_serialize(
            invoice_id=invoice_id,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_print_custom_auth_form_serialize(
        self,
        invoice_id,
        time_zone_offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        if time_zone_offset is not None:
            
            _query_params.append(('timeZoneOffset', time_zone_offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/print-auth-form',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_process_payment(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        payment: Annotated[Payment, Field(description="Payment object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_process_payment

        Process a payment for a invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param payment: Payment object (required)
        :type payment: Payment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_payment_serialize(
            invoice_id=invoice_id,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_process_payment_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        payment: Annotated[Payment, Field(description="Payment object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_process_payment

        Process a payment for a invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param payment: Payment object (required)
        :type payment: Payment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_payment_serialize(
            invoice_id=invoice_id,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_process_payment_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        payment: Annotated[Payment, Field(description="Payment object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_process_payment

        Process a payment for a invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param payment: Payment object (required)
        :type payment: Payment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_payment_serialize(
            invoice_id=invoice_id,
            payment=payment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_process_payment_serialize(
        self,
        invoice_id,
        payment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if payment is not None:
            _body_params = payment


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/{invoice-id}/payment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_process_refund(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        transaction_id: Annotated[StrictInt, Field(description="The transaction id")],
        refund_request: Annotated[RefundRequest, Field(description="Refund object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_process_refund

        Refunds a payment to the card used

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param transaction_id: The transaction id (required)
        :type transaction_id: int
        :param refund_request: Refund object (required)
        :type refund_request: RefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_refund_serialize(
            invoice_id=invoice_id,
            transaction_id=transaction_id,
            refund_request=refund_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_process_refund_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        transaction_id: Annotated[StrictInt, Field(description="The transaction id")],
        refund_request: Annotated[RefundRequest, Field(description="Refund object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_process_refund

        Refunds a payment to the card used

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param transaction_id: The transaction id (required)
        :type transaction_id: int
        :param refund_request: Refund object (required)
        :type refund_request: RefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_refund_serialize(
            invoice_id=invoice_id,
            transaction_id=transaction_id,
            refund_request=refund_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_process_refund_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        transaction_id: Annotated[StrictInt, Field(description="The transaction id")],
        refund_request: Annotated[RefundRequest, Field(description="Refund object")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_process_refund

        Refunds a payment to the card used

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param transaction_id: The transaction id (required)
        :type transaction_id: int
        :param refund_request: Refund object (required)
        :type refund_request: RefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_process_refund_serialize(
            invoice_id=invoice_id,
            transaction_id=transaction_id,
            refund_request=refund_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_process_refund_serialize(
        self,
        invoice_id,
        transaction_id,
        refund_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if transaction_id is not None:
            _path_params['transaction-id'] = transaction_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if refund_request is not None:
            _body_params = refund_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/{invoice-id}/transactions/{transaction-id}/refund',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_remove_tag(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) invoices_remove_tag

        Deletes a tag for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag: Tag to be removed from the invoice (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /invoices/{invoice-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._invoices_remove_tag_serialize(
            invoice_id=invoice_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_remove_tag_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) invoices_remove_tag

        Deletes a tag for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag: Tag to be removed from the invoice (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /invoices/{invoice-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._invoices_remove_tag_serialize(
            invoice_id=invoice_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_remove_tag_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The invoice Id")],
        tag: Annotated[StrictStr, Field(description="Tag to be removed from the invoice")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) invoices_remove_tag

        Deletes a tag for an invoice

        :param invoice_id: The invoice Id (required)
        :type invoice_id: int
        :param tag: Tag to be removed from the invoice (required)
        :type tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /invoices/{invoice-id}/tags/{tag} is deprecated.", DeprecationWarning)

        _param = self._invoices_remove_tag_serialize(
            invoice_id=invoice_id,
            tag=tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_remove_tag_serialize(
        self,
        invoice_id,
        tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if tag is not None:
            _path_params['tag'] = tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/invoices/{invoice-id}/tags/{tag}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_search(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Customer display name search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Invoice creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Invoice creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Invoice last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Invoice last update date to range filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        payment_date_from: Annotated[Optional[datetime], Field(description="Invoice payment date from range filter")] = None,
        payment_date_to: Annotated[Optional[datetime], Field(description="Invoice payment date to range filter")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="Invoice fulfillment date from range filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="Invoice fulfillment date to range filter")] = None,
        payment_ref: Annotated[Optional[StrictStr], Field(description="Payment reference search filter")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        purchase_line_id: Annotated[Optional[StrictInt], Field(description="Purchase line Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_transaction_info: Annotated[Optional[StrictBool], Field(description="Whether the results include transaction info")] = None,
        received: Annotated[Optional[StrictStr], Field(description="Whether the results are received")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        min_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total search filter")] = None,
        max_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total search filter")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="User id that added the last invoice note search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[InvoiceSummary]:
        """invoices_search

        Searches invoices

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param display_name: Customer display name search filter
        :type display_name: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param id: Invoice Id search filter
        :type id: List[int]
        :param created_date_from: Invoice creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Invoice creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Invoice last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Invoice last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param payment_date_from: Invoice payment date from range filter
        :type payment_date_from: datetime
        :param payment_date_to: Invoice payment date to range filter
        :type payment_date_to: datetime
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param fulfillment_date_from: Invoice fulfillment date from range filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: Invoice fulfillment date to range filter
        :type fulfillment_date_to: datetime
        :param payment_ref: Payment reference search filter
        :type payment_ref: str
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param performer: Performer search filter
        :type performer: str
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param customer_id: Customer Id search filter
        :type customer_id: int
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param created_by: Email search filter for invoice creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param purchase_line_id: Purchase line Id search filter
        :type purchase_line_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_transaction_info: Whether the results include transaction info
        :type include_transaction_info: bool
        :param received: Whether the results are received
        :type received: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param min_total: Minimum total search filter
        :type min_total: float
        :param max_total: Maximum total search filter
        :type max_total: float
        :param min_outstanding_balance: Minimum outstanding balance
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance
        :type max_outstanding_balance: float
        :param invoice_notes_user_id: User id that added the last invoice note search filter
        :type invoice_notes_user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            display_name=display_name,
            vendor_id=vendor_id,
            id=id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            payment_status=payment_status,
            payment_date_from=payment_date_from,
            payment_date_to=payment_date_to,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            payment_ref=payment_ref,
            barcodes_entered=barcodes_entered,
            files_uploaded=files_uploaded,
            zone_seating=zone_seating,
            performer_id=performer_id,
            performer=performer,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            customer_id=customer_id,
            event_type=event_type,
            category_id=category_id,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            no_tags=no_tags,
            currency_code=currency_code,
            event_id=event_id,
            internal_id=internal_id,
            purchase_id=purchase_id,
            purchase_line_id=purchase_line_id,
            sorted_by=sorted_by,
            include_transaction_info=include_transaction_info,
            received=received,
            venue_id=venue_id,
            venue=venue,
            stock_type=stock_type,
            min_total=min_total,
            max_total=max_total,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            invoice_notes_user_id=invoice_notes_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_search_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Customer display name search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Invoice creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Invoice creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Invoice last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Invoice last update date to range filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        payment_date_from: Annotated[Optional[datetime], Field(description="Invoice payment date from range filter")] = None,
        payment_date_to: Annotated[Optional[datetime], Field(description="Invoice payment date to range filter")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="Invoice fulfillment date from range filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="Invoice fulfillment date to range filter")] = None,
        payment_ref: Annotated[Optional[StrictStr], Field(description="Payment reference search filter")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        purchase_line_id: Annotated[Optional[StrictInt], Field(description="Purchase line Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_transaction_info: Annotated[Optional[StrictBool], Field(description="Whether the results include transaction info")] = None,
        received: Annotated[Optional[StrictStr], Field(description="Whether the results are received")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        min_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total search filter")] = None,
        max_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total search filter")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="User id that added the last invoice note search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[InvoiceSummary]]:
        """invoices_search

        Searches invoices

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param display_name: Customer display name search filter
        :type display_name: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param id: Invoice Id search filter
        :type id: List[int]
        :param created_date_from: Invoice creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Invoice creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Invoice last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Invoice last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param payment_date_from: Invoice payment date from range filter
        :type payment_date_from: datetime
        :param payment_date_to: Invoice payment date to range filter
        :type payment_date_to: datetime
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param fulfillment_date_from: Invoice fulfillment date from range filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: Invoice fulfillment date to range filter
        :type fulfillment_date_to: datetime
        :param payment_ref: Payment reference search filter
        :type payment_ref: str
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param performer: Performer search filter
        :type performer: str
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param customer_id: Customer Id search filter
        :type customer_id: int
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param created_by: Email search filter for invoice creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param purchase_line_id: Purchase line Id search filter
        :type purchase_line_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_transaction_info: Whether the results include transaction info
        :type include_transaction_info: bool
        :param received: Whether the results are received
        :type received: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param min_total: Minimum total search filter
        :type min_total: float
        :param max_total: Maximum total search filter
        :type max_total: float
        :param min_outstanding_balance: Minimum outstanding balance
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance
        :type max_outstanding_balance: float
        :param invoice_notes_user_id: User id that added the last invoice note search filter
        :type invoice_notes_user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            display_name=display_name,
            vendor_id=vendor_id,
            id=id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            payment_status=payment_status,
            payment_date_from=payment_date_from,
            payment_date_to=payment_date_to,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            payment_ref=payment_ref,
            barcodes_entered=barcodes_entered,
            files_uploaded=files_uploaded,
            zone_seating=zone_seating,
            performer_id=performer_id,
            performer=performer,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            customer_id=customer_id,
            event_type=event_type,
            category_id=category_id,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            no_tags=no_tags,
            currency_code=currency_code,
            event_id=event_id,
            internal_id=internal_id,
            purchase_id=purchase_id,
            purchase_line_id=purchase_line_id,
            sorted_by=sorted_by,
            include_transaction_info=include_transaction_info,
            received=received,
            venue_id=venue_id,
            venue=venue,
            stock_type=stock_type,
            min_total=min_total,
            max_total=max_total,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            invoice_notes_user_id=invoice_notes_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_search_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="Number of results per page")] = None,
        sort_dir: Annotated[Optional[StrictStr], Field(description="Direction to sort")] = None,
        page_number: Annotated[Optional[StrictInt], Field(description="Page number of results to show")] = None,
        delivery_method: Annotated[Optional[List[StrictStr]], Field(description="Delivery method search filter")] = None,
        tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to include")] = None,
        tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should have all the tags or only some")] = None,
        anti_tag: Annotated[Optional[List[StrictStr]], Field(description="Tags to exclude")] = None,
        anti_tags_match_all: Annotated[Optional[StrictBool], Field(description="Whether the results should not have all the tags or only some")] = None,
        display_name: Annotated[Optional[StrictStr], Field(description="Customer display name search filter")] = None,
        vendor_id: Annotated[Optional[List[StrictInt]], Field(description="Vendor Id search filter")] = None,
        id: Annotated[Optional[List[StrictInt]], Field(description="Invoice Id search filter")] = None,
        created_date_from: Annotated[Optional[datetime], Field(description="Invoice creation date from range filter")] = None,
        created_date_to: Annotated[Optional[datetime], Field(description="Invoice creation date to range filter")] = None,
        last_update_from: Annotated[Optional[datetime], Field(description="Invoice last update date from range filter")] = None,
        last_update_to: Annotated[Optional[datetime], Field(description="Invoice last update date to range filter")] = None,
        external_ref: Annotated[Optional[List[StrictStr]], Field(description="External reference search filter")] = None,
        payment_status: Annotated[Optional[List[StrictStr]], Field(description="Payment status search filter")] = None,
        payment_date_from: Annotated[Optional[datetime], Field(description="Invoice payment date from range filter")] = None,
        payment_date_to: Annotated[Optional[datetime], Field(description="Invoice payment date to range filter")] = None,
        invoice_status: Annotated[Optional[List[StrictStr]], Field(description="Invoice status search filter")] = None,
        fulfillment_status: Annotated[Optional[StrictStr], Field(description="Fulfillment status search filter")] = None,
        fulfillment_date_from: Annotated[Optional[datetime], Field(description="Invoice fulfillment date from range filter")] = None,
        fulfillment_date_to: Annotated[Optional[datetime], Field(description="Invoice fulfillment date to range filter")] = None,
        payment_ref: Annotated[Optional[StrictStr], Field(description="Payment reference search filter")] = None,
        barcodes_entered: Annotated[Optional[StrictBool], Field(description="Whether the results should have Bar Codes entered in all tickets")] = None,
        files_uploaded: Annotated[Optional[StrictBool], Field(description="Whether the results should have Pdfs attached to all tickets")] = None,
        zone_seating: Annotated[Optional[StrictBool], Field(description="Whether the results should have zone seating")] = None,
        performer_id: Annotated[Optional[StrictInt], Field(description="Performer Id search filter")] = None,
        performer: Annotated[Optional[StrictStr], Field(description="Performer search filter")] = None,
        in_hand_date_from: Annotated[Optional[datetime], Field(description="In hand date from range filter")] = None,
        in_hand_date_to: Annotated[Optional[datetime], Field(description="In hand date to range filter")] = None,
        event_date_from: Annotated[Optional[datetime], Field(description="Event date from range filter")] = None,
        event_date_to: Annotated[Optional[datetime], Field(description="Event date to range filter")] = None,
        customer_id: Annotated[Optional[StrictInt], Field(description="Customer Id search filter")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Event Type search filter")] = None,
        category_id: Annotated[Optional[StrictInt], Field(description="Category Id search filter")] = None,
        created_by: Annotated[Optional[StrictStr], Field(description="Email search filter for invoice creator")] = None,
        created_by_user_id: Annotated[Optional[StrictInt], Field(description="Id search filter for invoice creator")] = None,
        no_tags: Annotated[Optional[StrictBool], Field(description="Whether the results should have tags")] = None,
        currency_code: Annotated[Optional[StrictStr], Field(description="Currency type search filter")] = None,
        event_id: Annotated[Optional[List[StrictInt]], Field(description="Event Id search filter")] = None,
        internal_id: Annotated[Optional[StrictInt], Field(description="Internal Id search filter")] = None,
        purchase_id: Annotated[Optional[StrictInt], Field(description="Purchase Id search filter")] = None,
        purchase_line_id: Annotated[Optional[StrictInt], Field(description="Purchase line Id search filter")] = None,
        sorted_by: Annotated[Optional[StrictStr], Field(description="Field to sort by")] = None,
        include_transaction_info: Annotated[Optional[StrictBool], Field(description="Whether the results include transaction info")] = None,
        received: Annotated[Optional[StrictStr], Field(description="Whether the results are received")] = None,
        venue_id: Annotated[Optional[StrictInt], Field(description="Venue id search filter")] = None,
        venue: Annotated[Optional[StrictStr], Field(description="Venue search filter")] = None,
        stock_type: Annotated[Optional[StrictStr], Field(description="Stock Type search filter")] = None,
        min_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum total search filter")] = None,
        max_total: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum total search filter")] = None,
        min_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Minimum outstanding balance")] = None,
        max_outstanding_balance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Maximum outstanding balance")] = None,
        invoice_notes_user_id: Annotated[Optional[StrictInt], Field(description="User id that added the last invoice note search filter")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_search

        Searches invoices

        :param limit: Number of results per page
        :type limit: int
        :param sort_dir: Direction to sort
        :type sort_dir: str
        :param page_number: Page number of results to show
        :type page_number: int
        :param delivery_method: Delivery method search filter
        :type delivery_method: List[str]
        :param tag: Tags to include
        :type tag: List[str]
        :param tags_match_all: Whether the results should have all the tags or only some
        :type tags_match_all: bool
        :param anti_tag: Tags to exclude
        :type anti_tag: List[str]
        :param anti_tags_match_all: Whether the results should not have all the tags or only some
        :type anti_tags_match_all: bool
        :param display_name: Customer display name search filter
        :type display_name: str
        :param vendor_id: Vendor Id search filter
        :type vendor_id: List[int]
        :param id: Invoice Id search filter
        :type id: List[int]
        :param created_date_from: Invoice creation date from range filter
        :type created_date_from: datetime
        :param created_date_to: Invoice creation date to range filter
        :type created_date_to: datetime
        :param last_update_from: Invoice last update date from range filter
        :type last_update_from: datetime
        :param last_update_to: Invoice last update date to range filter
        :type last_update_to: datetime
        :param external_ref: External reference search filter
        :type external_ref: List[str]
        :param payment_status: Payment status search filter
        :type payment_status: List[str]
        :param payment_date_from: Invoice payment date from range filter
        :type payment_date_from: datetime
        :param payment_date_to: Invoice payment date to range filter
        :type payment_date_to: datetime
        :param invoice_status: Invoice status search filter
        :type invoice_status: List[str]
        :param fulfillment_status: Fulfillment status search filter
        :type fulfillment_status: str
        :param fulfillment_date_from: Invoice fulfillment date from range filter
        :type fulfillment_date_from: datetime
        :param fulfillment_date_to: Invoice fulfillment date to range filter
        :type fulfillment_date_to: datetime
        :param payment_ref: Payment reference search filter
        :type payment_ref: str
        :param barcodes_entered: Whether the results should have Bar Codes entered in all tickets
        :type barcodes_entered: bool
        :param files_uploaded: Whether the results should have Pdfs attached to all tickets
        :type files_uploaded: bool
        :param zone_seating: Whether the results should have zone seating
        :type zone_seating: bool
        :param performer_id: Performer Id search filter
        :type performer_id: int
        :param performer: Performer search filter
        :type performer: str
        :param in_hand_date_from: In hand date from range filter
        :type in_hand_date_from: datetime
        :param in_hand_date_to: In hand date to range filter
        :type in_hand_date_to: datetime
        :param event_date_from: Event date from range filter
        :type event_date_from: datetime
        :param event_date_to: Event date to range filter
        :type event_date_to: datetime
        :param customer_id: Customer Id search filter
        :type customer_id: int
        :param event_type: Event Type search filter
        :type event_type: str
        :param category_id: Category Id search filter
        :type category_id: int
        :param created_by: Email search filter for invoice creator
        :type created_by: str
        :param created_by_user_id: Id search filter for invoice creator
        :type created_by_user_id: int
        :param no_tags: Whether the results should have tags
        :type no_tags: bool
        :param currency_code: Currency type search filter
        :type currency_code: str
        :param event_id: Event Id search filter
        :type event_id: List[int]
        :param internal_id: Internal Id search filter
        :type internal_id: int
        :param purchase_id: Purchase Id search filter
        :type purchase_id: int
        :param purchase_line_id: Purchase line Id search filter
        :type purchase_line_id: int
        :param sorted_by: Field to sort by
        :type sorted_by: str
        :param include_transaction_info: Whether the results include transaction info
        :type include_transaction_info: bool
        :param received: Whether the results are received
        :type received: str
        :param venue_id: Venue id search filter
        :type venue_id: int
        :param venue: Venue search filter
        :type venue: str
        :param stock_type: Stock Type search filter
        :type stock_type: str
        :param min_total: Minimum total search filter
        :type min_total: float
        :param max_total: Maximum total search filter
        :type max_total: float
        :param min_outstanding_balance: Minimum outstanding balance
        :type min_outstanding_balance: float
        :param max_outstanding_balance: Maximum outstanding balance
        :type max_outstanding_balance: float
        :param invoice_notes_user_id: User id that added the last invoice note search filter
        :type invoice_notes_user_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_search_serialize(
            limit=limit,
            sort_dir=sort_dir,
            page_number=page_number,
            delivery_method=delivery_method,
            tag=tag,
            tags_match_all=tags_match_all,
            anti_tag=anti_tag,
            anti_tags_match_all=anti_tags_match_all,
            display_name=display_name,
            vendor_id=vendor_id,
            id=id,
            created_date_from=created_date_from,
            created_date_to=created_date_to,
            last_update_from=last_update_from,
            last_update_to=last_update_to,
            external_ref=external_ref,
            payment_status=payment_status,
            payment_date_from=payment_date_from,
            payment_date_to=payment_date_to,
            invoice_status=invoice_status,
            fulfillment_status=fulfillment_status,
            fulfillment_date_from=fulfillment_date_from,
            fulfillment_date_to=fulfillment_date_to,
            payment_ref=payment_ref,
            barcodes_entered=barcodes_entered,
            files_uploaded=files_uploaded,
            zone_seating=zone_seating,
            performer_id=performer_id,
            performer=performer,
            in_hand_date_from=in_hand_date_from,
            in_hand_date_to=in_hand_date_to,
            event_date_from=event_date_from,
            event_date_to=event_date_to,
            customer_id=customer_id,
            event_type=event_type,
            category_id=category_id,
            created_by=created_by,
            created_by_user_id=created_by_user_id,
            no_tags=no_tags,
            currency_code=currency_code,
            event_id=event_id,
            internal_id=internal_id,
            purchase_id=purchase_id,
            purchase_line_id=purchase_line_id,
            sorted_by=sorted_by,
            include_transaction_info=include_transaction_info,
            received=received,
            venue_id=venue_id,
            venue=venue,
            stock_type=stock_type,
            min_total=min_total,
            max_total=max_total,
            min_outstanding_balance=min_outstanding_balance,
            max_outstanding_balance=max_outstanding_balance,
            invoice_notes_user_id=invoice_notes_user_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[InvoiceSummary]",
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_search_serialize(
        self,
        limit,
        sort_dir,
        page_number,
        delivery_method,
        tag,
        tags_match_all,
        anti_tag,
        anti_tags_match_all,
        display_name,
        vendor_id,
        id,
        created_date_from,
        created_date_to,
        last_update_from,
        last_update_to,
        external_ref,
        payment_status,
        payment_date_from,
        payment_date_to,
        invoice_status,
        fulfillment_status,
        fulfillment_date_from,
        fulfillment_date_to,
        payment_ref,
        barcodes_entered,
        files_uploaded,
        zone_seating,
        performer_id,
        performer,
        in_hand_date_from,
        in_hand_date_to,
        event_date_from,
        event_date_to,
        customer_id,
        event_type,
        category_id,
        created_by,
        created_by_user_id,
        no_tags,
        currency_code,
        event_id,
        internal_id,
        purchase_id,
        purchase_line_id,
        sorted_by,
        include_transaction_info,
        received,
        venue_id,
        venue,
        stock_type,
        min_total,
        max_total,
        min_outstanding_balance,
        max_outstanding_balance,
        invoice_notes_user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'deliveryMethod': 'multi',
            'tag': 'multi',
            'antiTag': 'multi',
            'vendorId': 'multi',
            'id': 'multi',
            'externalRef': 'multi',
            'paymentStatus': 'multi',
            'invoiceStatus': 'multi',
            'eventId': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_dir is not None:
            
            _query_params.append(('sortDir', sort_dir))
            
        if page_number is not None:
            
            _query_params.append(('pageNumber', page_number))
            
        if delivery_method is not None:
            
            _query_params.append(('deliveryMethod', delivery_method))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if tags_match_all is not None:
            
            _query_params.append(('tagsMatchAll', tags_match_all))
            
        if anti_tag is not None:
            
            _query_params.append(('antiTag', anti_tag))
            
        if anti_tags_match_all is not None:
            
            _query_params.append(('antiTagsMatchAll', anti_tags_match_all))
            
        if display_name is not None:
            
            _query_params.append(('displayName', display_name))
            
        if vendor_id is not None:
            
            _query_params.append(('vendorId', vendor_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if created_date_from is not None:
            if isinstance(created_date_from, datetime):
                _query_params.append(
                    (
                        'createdDateFrom',
                        created_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdDateFrom', created_date_from))
            
        if created_date_to is not None:
            if isinstance(created_date_to, datetime):
                _query_params.append(
                    (
                        'createdDateTo',
                        created_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdDateTo', created_date_to))
            
        if last_update_from is not None:
            if isinstance(last_update_from, datetime):
                _query_params.append(
                    (
                        'lastUpdateFrom',
                        last_update_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateFrom', last_update_from))
            
        if last_update_to is not None:
            if isinstance(last_update_to, datetime):
                _query_params.append(
                    (
                        'lastUpdateTo',
                        last_update_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastUpdateTo', last_update_to))
            
        if external_ref is not None:
            
            _query_params.append(('externalRef', external_ref))
            
        if payment_status is not None:
            
            _query_params.append(('paymentStatus', payment_status))
            
        if payment_date_from is not None:
            if isinstance(payment_date_from, datetime):
                _query_params.append(
                    (
                        'paymentDateFrom',
                        payment_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('paymentDateFrom', payment_date_from))
            
        if payment_date_to is not None:
            if isinstance(payment_date_to, datetime):
                _query_params.append(
                    (
                        'paymentDateTo',
                        payment_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('paymentDateTo', payment_date_to))
            
        if invoice_status is not None:
            
            _query_params.append(('invoiceStatus', invoice_status))
            
        if fulfillment_status is not None:
            
            _query_params.append(('fulfillmentStatus', fulfillment_status))
            
        if fulfillment_date_from is not None:
            if isinstance(fulfillment_date_from, datetime):
                _query_params.append(
                    (
                        'fulfillmentDateFrom',
                        fulfillment_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fulfillmentDateFrom', fulfillment_date_from))
            
        if fulfillment_date_to is not None:
            if isinstance(fulfillment_date_to, datetime):
                _query_params.append(
                    (
                        'fulfillmentDateTo',
                        fulfillment_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('fulfillmentDateTo', fulfillment_date_to))
            
        if payment_ref is not None:
            
            _query_params.append(('paymentRef', payment_ref))
            
        if barcodes_entered is not None:
            
            _query_params.append(('barcodesEntered', barcodes_entered))
            
        if files_uploaded is not None:
            
            _query_params.append(('filesUploaded', files_uploaded))
            
        if zone_seating is not None:
            
            _query_params.append(('zoneSeating', zone_seating))
            
        if performer_id is not None:
            
            _query_params.append(('performerId', performer_id))
            
        if performer is not None:
            
            _query_params.append(('performer', performer))
            
        if in_hand_date_from is not None:
            if isinstance(in_hand_date_from, datetime):
                _query_params.append(
                    (
                        'inHandDateFrom',
                        in_hand_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateFrom', in_hand_date_from))
            
        if in_hand_date_to is not None:
            if isinstance(in_hand_date_to, datetime):
                _query_params.append(
                    (
                        'inHandDateTo',
                        in_hand_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('inHandDateTo', in_hand_date_to))
            
        if event_date_from is not None:
            if isinstance(event_date_from, datetime):
                _query_params.append(
                    (
                        'eventDateFrom',
                        event_date_from.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateFrom', event_date_from))
            
        if event_date_to is not None:
            if isinstance(event_date_to, datetime):
                _query_params.append(
                    (
                        'eventDateTo',
                        event_date_to.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('eventDateTo', event_date_to))
            
        if customer_id is not None:
            
            _query_params.append(('customerId', customer_id))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if created_by is not None:
            
            _query_params.append(('createdBy', created_by))
            
        if created_by_user_id is not None:
            
            _query_params.append(('createdByUserId', created_by_user_id))
            
        if no_tags is not None:
            
            _query_params.append(('noTags', no_tags))
            
        if currency_code is not None:
            
            _query_params.append(('currencyCode', currency_code))
            
        if event_id is not None:
            
            _query_params.append(('eventId', event_id))
            
        if internal_id is not None:
            
            _query_params.append(('internalId', internal_id))
            
        if purchase_id is not None:
            
            _query_params.append(('purchaseId', purchase_id))
            
        if purchase_line_id is not None:
            
            _query_params.append(('purchaseLineId', purchase_line_id))
            
        if sorted_by is not None:
            
            _query_params.append(('sortedBy', sorted_by))
            
        if include_transaction_info is not None:
            
            _query_params.append(('includeTransactionInfo', include_transaction_info))
            
        if received is not None:
            
            _query_params.append(('received', received))
            
        if venue_id is not None:
            
            _query_params.append(('venueId', venue_id))
            
        if venue is not None:
            
            _query_params.append(('venue', venue))
            
        if stock_type is not None:
            
            _query_params.append(('stockType', stock_type))
            
        if min_total is not None:
            
            _query_params.append(('minTotal', min_total))
            
        if max_total is not None:
            
            _query_params.append(('maxTotal', max_total))
            
        if min_outstanding_balance is not None:
            
            _query_params.append(('minOutstandingBalance', min_outstanding_balance))
            
        if max_outstanding_balance is not None:
            
            _query_params.append(('maxOutstandingBalance', max_outstanding_balance))
            
        if invoice_notes_user_id is not None:
            
            _query_params.append(('invoiceNotesUserId', invoice_notes_user_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_send(
        self,
        invoice_id: Annotated[int, Field(strict=True, ge=1, description="Id of the invoice")],
        email_address: Annotated[List[StrictStr], Field(description="The customer's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_invoice: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice in the body")] = None,
        attach_tickets: Annotated[Optional[StrictBool], Field(description="Whether the email includes tickets attached")] = None,
        attach_invoice_pdf: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice PDF attached")] = None,
        attach_auth_form: Annotated[Optional[StrictBool], Field(description="Whether the email includes the auth form PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_send

        Sends an Invoice to the customer's email address

        :param invoice_id: Id of the invoice (required)
        :type invoice_id: int
        :param email_address: The customer's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The customer's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The customer's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_invoice: Whether the email includes the invoice in the body
        :type include_invoice: bool
        :param attach_tickets: Whether the email includes tickets attached
        :type attach_tickets: bool
        :param attach_invoice_pdf: Whether the email includes the invoice PDF attached
        :type attach_invoice_pdf: bool
        :param attach_auth_form: Whether the email includes the auth form PDF attached
        :type attach_auth_form: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_send_serialize(
            invoice_id=invoice_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_invoice=include_invoice,
            attach_tickets=attach_tickets,
            attach_invoice_pdf=attach_invoice_pdf,
            attach_auth_form=attach_auth_form,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_send_with_http_info(
        self,
        invoice_id: Annotated[int, Field(strict=True, ge=1, description="Id of the invoice")],
        email_address: Annotated[List[StrictStr], Field(description="The customer's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_invoice: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice in the body")] = None,
        attach_tickets: Annotated[Optional[StrictBool], Field(description="Whether the email includes tickets attached")] = None,
        attach_invoice_pdf: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice PDF attached")] = None,
        attach_auth_form: Annotated[Optional[StrictBool], Field(description="Whether the email includes the auth form PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_send

        Sends an Invoice to the customer's email address

        :param invoice_id: Id of the invoice (required)
        :type invoice_id: int
        :param email_address: The customer's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The customer's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The customer's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_invoice: Whether the email includes the invoice in the body
        :type include_invoice: bool
        :param attach_tickets: Whether the email includes tickets attached
        :type attach_tickets: bool
        :param attach_invoice_pdf: Whether the email includes the invoice PDF attached
        :type attach_invoice_pdf: bool
        :param attach_auth_form: Whether the email includes the auth form PDF attached
        :type attach_auth_form: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_send_serialize(
            invoice_id=invoice_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_invoice=include_invoice,
            attach_tickets=attach_tickets,
            attach_invoice_pdf=attach_invoice_pdf,
            attach_auth_form=attach_auth_form,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_send_without_preload_content(
        self,
        invoice_id: Annotated[int, Field(strict=True, ge=1, description="Id of the invoice")],
        email_address: Annotated[List[StrictStr], Field(description="The customer's email addresses in the To email field")],
        cc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Cc email field")] = None,
        bcc_email_address: Annotated[Optional[List[StrictStr]], Field(description="The customer's email addresses in the Bcc email field")] = None,
        subject: Annotated[Optional[StrictStr], Field(description="Subject of the email")] = None,
        message: Annotated[Optional[StrictStr], Field(description="Message of the email")] = None,
        include_invoice: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice in the body")] = None,
        attach_tickets: Annotated[Optional[StrictBool], Field(description="Whether the email includes tickets attached")] = None,
        attach_invoice_pdf: Annotated[Optional[StrictBool], Field(description="Whether the email includes the invoice PDF attached")] = None,
        attach_auth_form: Annotated[Optional[StrictBool], Field(description="Whether the email includes the auth form PDF attached")] = None,
        time_zone_offset: Annotated[Optional[StrictInt], Field(description="Time zone off set")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_send

        Sends an Invoice to the customer's email address

        :param invoice_id: Id of the invoice (required)
        :type invoice_id: int
        :param email_address: The customer's email addresses in the To email field (required)
        :type email_address: List[str]
        :param cc_email_address: The customer's email addresses in the Cc email field
        :type cc_email_address: List[str]
        :param bcc_email_address: The customer's email addresses in the Bcc email field
        :type bcc_email_address: List[str]
        :param subject: Subject of the email
        :type subject: str
        :param message: Message of the email
        :type message: str
        :param include_invoice: Whether the email includes the invoice in the body
        :type include_invoice: bool
        :param attach_tickets: Whether the email includes tickets attached
        :type attach_tickets: bool
        :param attach_invoice_pdf: Whether the email includes the invoice PDF attached
        :type attach_invoice_pdf: bool
        :param attach_auth_form: Whether the email includes the auth form PDF attached
        :type attach_auth_form: bool
        :param time_zone_offset: Time zone off set
        :type time_zone_offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_send_serialize(
            invoice_id=invoice_id,
            email_address=email_address,
            cc_email_address=cc_email_address,
            bcc_email_address=bcc_email_address,
            subject=subject,
            message=message,
            include_invoice=include_invoice,
            attach_tickets=attach_tickets,
            attach_invoice_pdf=attach_invoice_pdf,
            attach_auth_form=attach_auth_form,
            time_zone_offset=time_zone_offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_send_serialize(
        self,
        invoice_id,
        email_address,
        cc_email_address,
        bcc_email_address,
        subject,
        message,
        include_invoice,
        attach_tickets,
        attach_invoice_pdf,
        attach_auth_form,
        time_zone_offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'emailAddress': 'multi',
            'ccEmailAddress': 'multi',
            'bccEmailAddress': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if cc_email_address is not None:
            
            _query_params.append(('ccEmailAddress', cc_email_address))
            
        if bcc_email_address is not None:
            
            _query_params.append(('bccEmailAddress', bcc_email_address))
            
        if subject is not None:
            
            _query_params.append(('subject', subject))
            
        if message is not None:
            
            _query_params.append(('message', message))
            
        if include_invoice is not None:
            
            _query_params.append(('includeInvoice', include_invoice))
            
        if attach_tickets is not None:
            
            _query_params.append(('attachTickets', attach_tickets))
            
        if attach_invoice_pdf is not None:
            
            _query_params.append(('attachInvoicePDF', attach_invoice_pdf))
            
        if attach_auth_form is not None:
            
            _query_params.append(('attachAuthForm', attach_auth_form))
            
        if time_zone_offset is not None:
            
            _query_params.append(('timeZoneOffset', time_zone_offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/invoices/{invoice-id}/send',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_tag(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_tag

        Inserts a new tags for an invoice. Duplicates are ignored

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_tag_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_tag_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_tag

        Inserts a new tags for an invoice. Duplicates are ignored

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_tag_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_tag_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        tag_request: Annotated[List[TagRequest], Field(description="Tags to add")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_tag

        Inserts a new tags for an invoice. Duplicates are ignored

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param tag_request: Tags to add (required)
        :type tag_request: List[TagRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_tag_serialize(
            invoice_id=invoice_id,
            tag_request=tag_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_tag_serialize(
        self,
        invoice_id,
        tag_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'TagRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tag_request is not None:
            _body_params = tag_request



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/invoices/{invoice-id}/tags',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_update(
        self,
        bulk_invoice_update: Annotated[BulkInvoiceUpdate, Field(description="Bulk invoice update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_update

        Bulk Invoice Update

        :param bulk_invoice_update: Bulk invoice update (required)
        :type bulk_invoice_update: BulkInvoiceUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_serialize(
            bulk_invoice_update=bulk_invoice_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_update_with_http_info(
        self,
        bulk_invoice_update: Annotated[BulkInvoiceUpdate, Field(description="Bulk invoice update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_update

        Bulk Invoice Update

        :param bulk_invoice_update: Bulk invoice update (required)
        :type bulk_invoice_update: BulkInvoiceUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_serialize(
            bulk_invoice_update=bulk_invoice_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_update_without_preload_content(
        self,
        bulk_invoice_update: Annotated[BulkInvoiceUpdate, Field(description="Bulk invoice update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_update

        Bulk Invoice Update

        :param bulk_invoice_update: Bulk invoice update (required)
        :type bulk_invoice_update: BulkInvoiceUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_serialize(
            bulk_invoice_update=bulk_invoice_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_update_serialize(
        self,
        bulk_invoice_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bulk_invoice_update is not None:
            _body_params = bulk_invoice_update



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/invoices/bulk',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_update_currency(
        self,
        invoice_currency_update_bulk_action: Annotated[InvoiceCurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """invoices_update_currency

        Converts invoice currency using an exchange rate

        :param invoice_currency_update_bulk_action: Payload for bulk action (required)
        :type invoice_currency_update_bulk_action: InvoiceCurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_currency_serialize(
            invoice_currency_update_bulk_action=invoice_currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_update_currency_with_http_info(
        self,
        invoice_currency_update_bulk_action: Annotated[InvoiceCurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """invoices_update_currency

        Converts invoice currency using an exchange rate

        :param invoice_currency_update_bulk_action: Payload for bulk action (required)
        :type invoice_currency_update_bulk_action: InvoiceCurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_currency_serialize(
            invoice_currency_update_bulk_action=invoice_currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_update_currency_without_preload_content(
        self,
        invoice_currency_update_bulk_action: Annotated[InvoiceCurrencyUpdateBulkAction, Field(description="Payload for bulk action")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_update_currency

        Converts invoice currency using an exchange rate

        :param invoice_currency_update_bulk_action: Payload for bulk action (required)
        :type invoice_currency_update_bulk_action: InvoiceCurrencyUpdateBulkAction
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_currency_serialize(
            invoice_currency_update_bulk_action=invoice_currency_update_bulk_action,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_update_currency_serialize(
        self,
        invoice_currency_update_bulk_action,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if invoice_currency_update_bulk_action is not None:
            _body_params = invoice_currency_update_bulk_action



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/invoices/actions/update-invoice-currency',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_update_invoice(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        invoice: Annotated[Invoice, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Invoice:
        """invoices_update_invoice

        Updates an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param invoice: An invoice object to update. (required)
        :type invoice: Invoice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_serialize(
            invoice_id=invoice_id,
            invoice=invoice,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_update_invoice_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        invoice: Annotated[Invoice, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Invoice]:
        """invoices_update_invoice

        Updates an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param invoice: An invoice object to update. (required)
        :type invoice: Invoice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_serialize(
            invoice_id=invoice_id,
            invoice=invoice,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_update_invoice_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        invoice: Annotated[Invoice, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_update_invoice

        Updates an invoice

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param invoice: An invoice object to update. (required)
        :type invoice: Invoice
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_serialize(
            invoice_id=invoice_id,
            invoice=invoice,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Invoice",
            '401': None,
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_update_invoice_serialize(
        self,
        invoice_id,
        invoice,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if invoice is not None:
            _body_params = invoice


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/invoices/{invoice-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def invoices_update_invoice_line(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Line:
        """invoices_update_invoice_line

        Updates an invoice line. Only quantity, amount, and description can be updated.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def invoices_update_invoice_line_with_http_info(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Line]:
        """invoices_update_invoice_line

        Updates an invoice line. Only quantity, amount, and description can be updated.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def invoices_update_invoice_line_without_preload_content(
        self,
        invoice_id: Annotated[StrictInt, Field(description="The id of the invoice")],
        line_id: Annotated[StrictInt, Field(description="The line id of the invoice")],
        line: Annotated[Line, Field(description="An invoice object to update.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """invoices_update_invoice_line

        Updates an invoice line. Only quantity, amount, and description can be updated.

        :param invoice_id: The id of the invoice (required)
        :type invoice_id: int
        :param line_id: The line id of the invoice (required)
        :type line_id: int
        :param line: An invoice object to update. (required)
        :type line: Line
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._invoices_update_invoice_line_serialize(
            invoice_id=invoice_id,
            line_id=line_id,
            line=line,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Line",
            '401': None,
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _invoices_update_invoice_line_serialize(
        self,
        invoice_id,
        line_id,
        line,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if invoice_id is not None:
            _path_params['invoice-id'] = invoice_id
        if line_id is not None:
            _path_params['line-id'] = line_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if line is not None:
            _body_params = line


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Account', 
            'Authorization_Token', 
            'Application_Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/invoices/{invoice-id}/lines/{line-id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


